{
  "language": "Solidity",
  "sources": {
    "contracts/CommunityPools.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n/**\r\n * CommunityPools - Rotating savings and community investment pools\r\n * Enables digital chamas and collective yield farming\r\n * @author SafeNest Team\r\n */\r\ncontract CommunityPools {\r\n    // State Variables\r\n    address public immutable owner;\r\n    string public platformName = \"Community Pools - Digital Chamas\";\r\n    \r\n    // Pool types\r\n    enum PoolType {\r\n        ROTATING_SAVINGS,    // Traditional chama - members take turns receiving funds\r\n        COLLECTIVE_INVESTMENT, // Pool funds for DeFi investments\r\n        EMERGENCY_FUND,      // Community emergency fund\r\n        GOAL_ORIENTED        // Pool for specific community goals\r\n    }\r\n    \r\n    // Pool structure\r\n    struct Pool {\r\n        uint256 id;\r\n        address creator;\r\n        string name;\r\n        string description;\r\n        PoolType poolType;\r\n        address stablecoin;\r\n        uint256 contributionAmount;\r\n        uint256 contributionFrequency; // in days\r\n        uint256 maxMembers;\r\n        uint256 currentMembers;\r\n        uint256 totalContributions;\r\n        uint256 poolBalance;\r\n        bool isActive;\r\n        bool isPublic;\r\n        uint256 createdAt;\r\n        uint256 nextContribution;\r\n        uint256 rotationIndex; // For rotating savings\r\n        mapping(address => bool) members;\r\n        mapping(address => uint256) memberContributions;\r\n        mapping(address => bool) hasReceived; // For rotating savings\r\n    }\r\n    \r\n    // Member structure\r\n    struct Member {\r\n        address user;\r\n        uint256 joinedAt;\r\n        uint256 totalContributed;\r\n        uint256 lastContribution;\r\n        bool isActive;\r\n        uint256 reputation;\r\n    }\r\n    \r\n    // Pool applications\r\n    struct PoolApplication {\r\n        address applicant;\r\n        uint256 poolId;\r\n        string message;\r\n        uint256 appliedAt;\r\n        bool isApproved;\r\n        bool isProcessed;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(uint256 => Pool) public pools;\r\n    mapping(address => Member[]) public userMemberships;\r\n    mapping(address => uint256[]) public userCreatedPools;\r\n    mapping(uint256 => PoolApplication[]) public poolApplications;\r\n    mapping(address => mapping(uint256 => bool)) public isMember;\r\n    \r\n    // Platform statistics\r\n    uint256 public totalPools = 0;\r\n    uint256 public totalMembers = 0;\r\n    uint256 public totalContributions = 0;\r\n    uint256 public nextPoolId = 1;\r\n    uint256 public platformFeeRate = 20; // 0.2% in basis points\r\n    \r\n    // Events\r\n    event PoolCreated(uint256 indexed poolId, address indexed creator, string name, PoolType poolType);\r\n    event MemberJoined(uint256 indexed poolId, address indexed member);\r\n    event MemberLeft(uint256 indexed poolId, address indexed member);\r\n    event ContributionMade(uint256 indexed poolId, address indexed member, uint256 amount);\r\n    event FundsDistributed(uint256 indexed poolId, address indexed recipient, uint256 amount);\r\n    event ApplicationSubmitted(uint256 indexed poolId, address indexed applicant);\r\n    event ApplicationApproved(uint256 indexed poolId, address indexed applicant);\r\n    event PoolCompleted(uint256 indexed poolId);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validPoolId(uint256 _poolId) {\r\n        require(_poolId < nextPoolId, \"Invalid pool ID\");\r\n        require(pools[_poolId].isActive, \"Pool not active\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPoolMember(uint256 _poolId) {\r\n        require(isMember[msg.sender][_poolId], \"Not a pool member\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPoolCreator(uint256 _poolId) {\r\n        require(pools[_poolId].creator == msg.sender, \"Not the pool creator\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * Create a new community pool\r\n     */\r\n    function createPool(\r\n        string memory _name,\r\n        string memory _description,\r\n        PoolType _poolType,\r\n        address _stablecoin,\r\n        uint256 _contributionAmount,\r\n        uint256 _contributionFrequency,\r\n        uint256 _maxMembers,\r\n        bool _isPublic\r\n    ) external {\r\n        require(bytes(_name).length > 0, \"Pool name required\");\r\n        require(_contributionAmount > 0, \"Contribution amount must be positive\");\r\n        require(_maxMembers > 1, \"Pool must have at least 2 members\");\r\n        require(_contributionFrequency > 0, \"Contribution frequency must be positive\");\r\n        \r\n        // Initialize pool struct\r\n        Pool storage newPool = pools[nextPoolId];\r\n        newPool.id = nextPoolId;\r\n        newPool.creator = msg.sender;\r\n        newPool.name = _name;\r\n        newPool.description = _description;\r\n        newPool.poolType = _poolType;\r\n        newPool.stablecoin = _stablecoin;\r\n        newPool.contributionAmount = _contributionAmount;\r\n        newPool.contributionFrequency = _contributionFrequency;\r\n        newPool.maxMembers = _maxMembers;\r\n        newPool.currentMembers = 0;\r\n        newPool.totalContributions = 0;\r\n        newPool.poolBalance = 0;\r\n        newPool.isActive = true;\r\n        newPool.isPublic = _isPublic;\r\n        newPool.createdAt = block.timestamp;\r\n        newPool.nextContribution = block.timestamp + _contributionFrequency * 1 days;\r\n        newPool.rotationIndex = 0;\r\n        \r\n        // Creator automatically becomes first member\r\n        newPool.members[msg.sender] = true;\r\n        newPool.currentMembers = 1;\r\n        isMember[msg.sender][nextPoolId] = true;\r\n        \r\n        userCreatedPools[msg.sender].push(nextPoolId);\r\n        totalPools++;\r\n        totalMembers++;\r\n        \r\n        emit PoolCreated(nextPoolId, msg.sender, _name, _poolType);\r\n        emit MemberJoined(nextPoolId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Join a public pool\r\n     */\r\n    function joinPool(uint256 _poolId) external validPoolId(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.isPublic, \"Pool is not public\");\r\n        require(!isMember[msg.sender][_poolId], \"Already a member\");\r\n        require(pool.currentMembers < pool.maxMembers, \"Pool is full\");\r\n        \r\n        pool.members[msg.sender] = true;\r\n        pool.currentMembers++;\r\n        isMember[msg.sender][_poolId] = true;\r\n        totalMembers++;\r\n        \r\n        userMemberships[msg.sender].push(Member({\r\n            user: msg.sender,\r\n            joinedAt: block.timestamp,\r\n            totalContributed: 0,\r\n            lastContribution: 0,\r\n            isActive: true,\r\n            reputation: 0\r\n        }));\r\n        \r\n        emit MemberJoined(_poolId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Apply to join a private pool\r\n     */\r\n    function applyToJoinPool(uint256 _poolId, string memory _message) external validPoolId(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(!pool.isPublic, \"Pool is public - use joinPool\");\r\n        require(!isMember[msg.sender][_poolId], \"Already a member\");\r\n        require(pool.currentMembers < pool.maxMembers, \"Pool is full\");\r\n        \r\n        poolApplications[_poolId].push(PoolApplication({\r\n            applicant: msg.sender,\r\n            poolId: _poolId,\r\n            message: _message,\r\n            appliedAt: block.timestamp,\r\n            isApproved: false,\r\n            isProcessed: false\r\n        }));\r\n        \r\n        emit ApplicationSubmitted(_poolId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Approve pool application (only pool creator)\r\n     */\r\n    function approveApplication(uint256 _poolId, uint256 _applicationIndex) external onlyPoolCreator(_poolId) {\r\n        require(_applicationIndex < poolApplications[_poolId].length, \"Invalid application index\");\r\n        \r\n        PoolApplication storage application = poolApplications[_poolId][_applicationIndex];\r\n        require(!application.isProcessed, \"Application already processed\");\r\n        \r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.currentMembers < pool.maxMembers, \"Pool is full\");\r\n        \r\n        application.isApproved = true;\r\n        application.isProcessed = true;\r\n        \r\n        pool.members[application.applicant] = true;\r\n        pool.currentMembers++;\r\n        isMember[application.applicant][_poolId] = true;\r\n        totalMembers++;\r\n        \r\n        userMemberships[application.applicant].push(Member({\r\n            user: application.applicant,\r\n            joinedAt: block.timestamp,\r\n            totalContributed: 0,\r\n            lastContribution: 0,\r\n            isActive: true,\r\n            reputation: 0\r\n        }));\r\n        \r\n        emit ApplicationApproved(_poolId, application.applicant);\r\n        emit MemberJoined(_poolId, application.applicant);\r\n    }\r\n    \r\n    /**\r\n     * Make contribution to pool\r\n     */\r\n    function contributeToPool(uint256 _poolId, uint256 _amount) external onlyPoolMember(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.isActive, \"Pool not active\");\r\n        require(_amount >= pool.contributionAmount, \"Contribution below minimum\");\r\n        require(block.timestamp >= pool.nextContribution, \"Too early for contribution\");\r\n        \r\n        // Transfer stablecoin from user\r\n        // Note: In production, use IERC20(pool.stablecoin).transferFrom(msg.sender, address(this), _amount)\r\n        \r\n        pool.memberContributions[msg.sender] += _amount;\r\n        pool.totalContributions += _amount;\r\n        pool.poolBalance += _amount;\r\n        \r\n        // Update member info\r\n        for (uint256 i = 0; i < userMemberships[msg.sender].length; i++) {\r\n            if (userMemberships[msg.sender][i].isActive) {\r\n                userMemberships[msg.sender][i].totalContributed += _amount;\r\n                userMemberships[msg.sender][i].lastContribution = block.timestamp;\r\n                userMemberships[msg.sender][i].reputation += 10; // Reputation points\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Update next contribution time\r\n        pool.nextContribution = block.timestamp + pool.contributionFrequency * 1 days;\r\n        \r\n        totalContributions += _amount;\r\n        \r\n        emit ContributionMade(_poolId, msg.sender, _amount);\r\n        \r\n        // Handle pool-specific logic\r\n        if (pool.poolType == PoolType.ROTATING_SAVINGS) {\r\n            _handleRotatingSavings(_poolId);\r\n        } else if (pool.poolType == PoolType.COLLECTIVE_INVESTMENT) {\r\n            _handleCollectiveInvestment(_poolId);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle rotating savings distribution\r\n     */\r\n    function _handleRotatingSavings(uint256 _poolId) internal {\r\n        Pool storage pool = pools[_poolId];\r\n        \r\n        // Check if it's time for distribution\r\n        if (pool.currentMembers > 0 && pool.poolBalance >= pool.contributionAmount * pool.currentMembers) {\r\n            // Find next member to receive funds\r\n            address[] memory members = _getPoolMembers(_poolId);\r\n            address recipient = members[pool.rotationIndex % members.length];\r\n            \r\n            // Ensure member hasn't received funds yet\r\n            while (pool.hasReceived[recipient] && pool.rotationIndex < members.length * 2) {\r\n                pool.rotationIndex++;\r\n                recipient = members[pool.rotationIndex % members.length];\r\n            }\r\n            \r\n            if (!pool.hasReceived[recipient]) {\r\n                uint256 distributionAmount = pool.contributionAmount * pool.currentMembers;\r\n                pool.poolBalance -= distributionAmount;\r\n                pool.hasReceived[recipient] = true;\r\n                pool.rotationIndex++;\r\n                \r\n                // Transfer funds to recipient\r\n                // Note: In production, use IERC20(pool.stablecoin).transfer(recipient, distributionAmount)\r\n                \r\n                emit FundsDistributed(_poolId, recipient, distributionAmount);\r\n                \r\n                // Check if all members have received funds\r\n                bool allReceived = true;\r\n                for (uint256 i = 0; i < members.length; i++) {\r\n                    if (!pool.hasReceived[members[i]]) {\r\n                        allReceived = false;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (allReceived) {\r\n                    pool.isActive = false;\r\n                    emit PoolCompleted(_poolId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle collective investment\r\n     */\r\n    function _handleCollectiveInvestment(uint256 _poolId) internal {\r\n        Pool storage pool = pools[_poolId];\r\n        \r\n        // In production, this would interact with DeFi protocols\r\n        // For now, we just track the balance\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from pool (for non-rotating pools)\r\n     */\r\n    function withdrawFromPool(uint256 _poolId, uint256 _amount) external onlyPoolMember(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.poolType != PoolType.ROTATING_SAVINGS, \"Cannot withdraw from rotating savings\");\r\n        require(pool.poolBalance >= _amount, \"Insufficient pool balance\");\r\n        require(pool.memberContributions[msg.sender] >= _amount, \"Insufficient contribution\");\r\n        \r\n        pool.poolBalance -= _amount;\r\n        pool.memberContributions[msg.sender] -= _amount;\r\n        \r\n        // Transfer funds to user\r\n        // Note: In production, use IERC20(pool.stablecoin).transfer(msg.sender, _amount)\r\n        \r\n        emit FundsDistributed(_poolId, msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Leave pool\r\n     */\r\n    function leavePool(uint256 _poolId) external onlyPoolMember(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.poolType != PoolType.ROTATING_SAVINGS, \"Cannot leave rotating savings pool\");\r\n        \r\n        pool.members[msg.sender] = false;\r\n        pool.currentMembers--;\r\n        isMember[msg.sender][_poolId] = false;\r\n        totalMembers--;\r\n        \r\n        // Update member status\r\n        for (uint256 i = 0; i < userMemberships[msg.sender].length; i++) {\r\n            if (userMemberships[msg.sender][i].isActive) {\r\n                userMemberships[msg.sender][i].isActive = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        emit MemberLeft(_poolId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Get pool members (simplified - in production, maintain a member list)\r\n     */\r\n    function _getPoolMembers(uint256 _poolId) internal view returns (address[] memory) {\r\n        // This is simplified - in production, maintain a proper member list\r\n        address[] memory members = new address[](0);\r\n        return members;\r\n    }\r\n    \r\n    /**\r\n     * Get pool details\r\n     */\r\n    function getPoolDetails(uint256 _poolId) external view validPoolId(_poolId) returns (\r\n        string memory name,\r\n        string memory description,\r\n        PoolType poolType,\r\n        address stablecoin,\r\n        uint256 contributionAmount,\r\n        uint256 contributionFrequency,\r\n        uint256 maxMembers,\r\n        uint256 currentMembers,\r\n        uint256 poolTotalContributions,\r\n        uint256 poolBalance,\r\n        bool isPublic,\r\n        uint256 createdAt\r\n    ) {\r\n        Pool storage pool = pools[_poolId];\r\n        return (\r\n            pool.name,\r\n            pool.description,\r\n            pool.poolType,\r\n            pool.stablecoin,\r\n            pool.contributionAmount,\r\n            pool.contributionFrequency,\r\n            pool.maxMembers,\r\n            pool.currentMembers,\r\n            pool.totalContributions,\r\n            pool.poolBalance,\r\n            pool.isPublic,\r\n            pool.createdAt\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Get user's pool memberships\r\n     */\r\n    function getUserMemberships(address _user) external view returns (uint256[] memory) {\r\n        uint256[] memory memberships = new uint256[](userMemberships[_user].length);\r\n        uint256 count = 0;\r\n        \r\n        for (uint256 i = 0; i < userMemberships[_user].length; i++) {\r\n            if (userMemberships[_user][i].isActive) {\r\n                memberships[count] = i; // Pool ID would be stored differently in production\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        return memberships;\r\n    }\r\n    \r\n    /**\r\n     * Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalPools,\r\n        uint256 _totalMembers,\r\n        uint256 _totalContributionsAmount,\r\n        uint256 _platformFeeRate\r\n    ) {\r\n        return (totalPools, totalMembers, totalContributions, platformFeeRate);\r\n    }\r\n    \r\n    /**\r\n     * Set platform fee rate (only owner)\r\n     */\r\n    function setPlatformFeeRate(uint256 _newRate) external onlyOwner {\r\n        require(_newRate <= 1000, \"Fee rate too high\"); // Max 10%\r\n        platformFeeRate = _newRate;\r\n    }\r\n}\r\n"
    },
    "contracts/CommunityPoolsAdvanced.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * CommunityPoolsAdvanced - Advanced community pools with digital chamas\r\n * Implements rotating savings, investment pools, and goal-oriented savings\r\n * @author SafeNest Team\r\n */\r\ncontract CommunityPoolsAdvanced {\r\n    // State Variables\r\n    address public immutable owner;\r\n    string public platformName = \"Community Pools Advanced - Digital Chamas\";\r\n    \r\n    // Pool types\r\n    enum PoolType {\r\n        ROTATING_SAVINGS,    // Traditional chama - members take turns receiving funds\r\n        COLLECTIVE_INVESTMENT, // Pool funds for DeFi investments\r\n        EMERGENCY_FUND,      // Community emergency fund\r\n        GOAL_ORIENTED        // Pool for specific community goals\r\n    }\r\n    \r\n    // Pool structure\r\n    struct Pool {\r\n        uint256 id;\r\n        address creator;\r\n        string name;\r\n        string description;\r\n        PoolType poolType;\r\n        uint256 contributionAmount;\r\n        uint256 contributionFrequency; // in days\r\n        uint256 maxMembers;\r\n        uint256 currentMembers;\r\n        uint256 totalContributions;\r\n        uint256 poolBalance;\r\n        uint256 yieldRate;\r\n        bool isActive;\r\n        bool isPublic;\r\n        uint256 createdAt;\r\n        uint256 nextContribution;\r\n        uint256 rotationIndex; // For rotating savings\r\n        uint256 lastDistribution;\r\n        mapping(address => bool) members;\r\n        mapping(address => uint256) memberContributions;\r\n        mapping(address => bool) hasReceived; // For rotating savings\r\n        mapping(address => uint256) memberShares;\r\n    }\r\n    \r\n    // Member structure\r\n    struct Member {\r\n        address user;\r\n        uint256 joinedAt;\r\n        uint256 totalContributed;\r\n        uint256 lastContribution;\r\n        bool isActive;\r\n        uint256 reputation;\r\n        uint256 shares;\r\n    }\r\n    \r\n    // Pool applications\r\n    struct PoolApplication {\r\n        address applicant;\r\n        uint256 poolId;\r\n        string message;\r\n        uint256 appliedAt;\r\n        bool isApproved;\r\n        bool isProcessed;\r\n    }\r\n    \r\n    // Pool statistics\r\n    struct PoolStats {\r\n        uint256 totalPools;\r\n        uint256 totalMembers;\r\n        uint256 totalContributions;\r\n        uint256 totalDistributions;\r\n        uint256 averageYield;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(uint256 => Pool) public pools;\r\n    mapping(address => Member[]) public userMemberships;\r\n    mapping(address => uint256[]) public userCreatedPools;\r\n    mapping(uint256 => PoolApplication[]) public poolApplications;\r\n    mapping(address => mapping(uint256 => bool)) public isMember;\r\n    mapping(address => uint256) public userReputation;\r\n    \r\n    // Platform statistics\r\n    PoolStats public platformStats;\r\n    uint256 public nextPoolId = 1;\r\n    uint256 public platformFeeRate = 20; // 0.2% in basis points\r\n    uint256 public reputationThreshold = 100; // Minimum reputation to create pools\r\n    \r\n    // Yield distribution\r\n    uint256 public totalYieldDistributed = 0;\r\n    uint256 public lastYieldDistribution = 0;\r\n    uint256 public yieldDistributionInterval = 7 days;\r\n    \r\n    // Events\r\n    event PoolCreated(uint256 indexed poolId, address indexed creator, string name, PoolType poolType);\r\n    event MemberJoined(uint256 indexed poolId, address indexed member);\r\n    event MemberLeft(uint256 indexed poolId, address indexed member);\r\n    event ContributionMade(uint256 indexed poolId, address indexed member, uint256 amount);\r\n    event FundsDistributed(uint256 indexed poolId, address indexed recipient, uint256 amount);\r\n    event ApplicationSubmitted(uint256 indexed poolId, address indexed applicant);\r\n    event ApplicationApproved(uint256 indexed poolId, address indexed applicant);\r\n    event PoolCompleted(uint256 indexed poolId);\r\n    event ReputationUpdated(address indexed user, uint256 oldReputation, uint256 newReputation);\r\n    event YieldDistributed(uint256 indexed poolId, uint256 amount, uint256 timestamp);\r\n    event PoolTypeChanged(uint256 indexed poolId, PoolType oldType, PoolType newType);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validPoolId(uint256 _poolId) {\r\n        require(_poolId < nextPoolId, \"Invalid pool ID\");\r\n        require(pools[_poolId].isActive, \"Pool not active\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPoolMember(uint256 _poolId) {\r\n        require(isMember[msg.sender][_poolId], \"Not a pool member\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPoolCreator(uint256 _poolId) {\r\n        require(pools[_poolId].creator == msg.sender, \"Not the pool creator\");\r\n        _;\r\n    }\r\n    \r\n    modifier validAmount(uint256 _amount) {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * Create a new community pool\r\n     */\r\n    function createPool(\r\n        string memory _name,\r\n        string memory _description,\r\n        PoolType _poolType,\r\n        uint256 _contributionAmount,\r\n        uint256 _contributionFrequency,\r\n        uint256 _maxMembers,\r\n        bool _isPublic\r\n    ) external {\r\n        require(bytes(_name).length > 0, \"Pool name required\");\r\n        require(_contributionAmount > 0, \"Contribution amount must be positive\");\r\n        require(_maxMembers > 1, \"Pool must have at least 2 members\");\r\n        require(_contributionFrequency > 0, \"Contribution frequency must be positive\");\r\n        require(userReputation[msg.sender] >= reputationThreshold, \"Insufficient reputation\");\r\n        \r\n        // Initialize pool struct\r\n        Pool storage newPool = pools[nextPoolId];\r\n        newPool.id = nextPoolId;\r\n        newPool.creator = msg.sender;\r\n        newPool.name = _name;\r\n        newPool.description = _description;\r\n        newPool.poolType = _poolType;\r\n        newPool.contributionAmount = _contributionAmount;\r\n        newPool.contributionFrequency = _contributionFrequency;\r\n        newPool.maxMembers = _maxMembers;\r\n        newPool.currentMembers = 0;\r\n        newPool.totalContributions = 0;\r\n        newPool.poolBalance = 0;\r\n        newPool.yieldRate = 0;\r\n        newPool.isActive = true;\r\n        newPool.isPublic = _isPublic;\r\n        newPool.createdAt = block.timestamp;\r\n        newPool.nextContribution = block.timestamp + _contributionFrequency * 1 days;\r\n        newPool.rotationIndex = 0;\r\n        newPool.lastDistribution = 0;\r\n        \r\n        // Creator automatically becomes first member\r\n        newPool.members[msg.sender] = true;\r\n        newPool.currentMembers = 1;\r\n        isMember[msg.sender][nextPoolId] = true;\r\n        \r\n        userCreatedPools[msg.sender].push(nextPoolId);\r\n        platformStats.totalPools++;\r\n        platformStats.totalMembers++;\r\n        \r\n        emit PoolCreated(nextPoolId, msg.sender, _name, _poolType);\r\n        emit MemberJoined(nextPoolId, msg.sender);\r\n        nextPoolId++;\r\n    }\r\n    \r\n    /**\r\n     * Join a public pool\r\n     */\r\n    function joinPool(uint256 _poolId) external validPoolId(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.isPublic, \"Pool is not public\");\r\n        require(!isMember[msg.sender][_poolId], \"Already a member\");\r\n        require(pool.currentMembers < pool.maxMembers, \"Pool is full\");\r\n        \r\n        pool.members[msg.sender] = true;\r\n        pool.currentMembers++;\r\n        isMember[msg.sender][_poolId] = true;\r\n        platformStats.totalMembers++;\r\n        \r\n        userMemberships[msg.sender].push(Member({\r\n            user: msg.sender,\r\n            joinedAt: block.timestamp,\r\n            totalContributed: 0,\r\n            lastContribution: 0,\r\n            isActive: true,\r\n            reputation: 0,\r\n            shares: 0\r\n        }));\r\n        \r\n        emit MemberJoined(_poolId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Apply to join a private pool\r\n     */\r\n    function applyToJoinPool(uint256 _poolId, string memory _message) external validPoolId(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(!pool.isPublic, \"Pool is public - use joinPool\");\r\n        require(!isMember[msg.sender][_poolId], \"Already a member\");\r\n        require(pool.currentMembers < pool.maxMembers, \"Pool is full\");\r\n        \r\n        poolApplications[_poolId].push(PoolApplication({\r\n            applicant: msg.sender,\r\n            poolId: _poolId,\r\n            message: _message,\r\n            appliedAt: block.timestamp,\r\n            isApproved: false,\r\n            isProcessed: false\r\n        }));\r\n        \r\n        emit ApplicationSubmitted(_poolId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Approve pool application (only pool creator)\r\n     */\r\n    function approveApplication(uint256 _poolId, uint256 _applicationIndex) external onlyPoolCreator(_poolId) {\r\n        require(_applicationIndex < poolApplications[_poolId].length, \"Invalid application index\");\r\n        \r\n        PoolApplication storage application = poolApplications[_poolId][_applicationIndex];\r\n        require(!application.isProcessed, \"Application already processed\");\r\n        \r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.currentMembers < pool.maxMembers, \"Pool is full\");\r\n        \r\n        application.isApproved = true;\r\n        application.isProcessed = true;\r\n        \r\n        pool.members[application.applicant] = true;\r\n        pool.currentMembers++;\r\n        isMember[application.applicant][_poolId] = true;\r\n        platformStats.totalMembers++;\r\n        \r\n        userMemberships[application.applicant].push(Member({\r\n            user: application.applicant,\r\n            joinedAt: block.timestamp,\r\n            totalContributed: 0,\r\n            lastContribution: 0,\r\n            isActive: true,\r\n            reputation: 0,\r\n            shares: 0\r\n        }));\r\n        \r\n        emit ApplicationApproved(_poolId, application.applicant);\r\n        emit MemberJoined(_poolId, application.applicant);\r\n    }\r\n    \r\n    /**\r\n     * Make contribution to pool\r\n     */\r\n    function contributeToPool(uint256 _poolId, uint256 _amount) external onlyPoolMember(_poolId) validAmount(_amount) payable {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.isActive, \"Pool not active\");\r\n        require(_amount >= pool.contributionAmount, \"Contribution below minimum\");\r\n        require(block.timestamp >= pool.nextContribution, \"Too early for contribution\");\r\n        require(msg.value >= _amount, \"Insufficient ETH sent\");\r\n        \r\n        pool.memberContributions[msg.sender] += _amount;\r\n        pool.totalContributions += _amount;\r\n        pool.poolBalance += _amount;\r\n        \r\n        // Update member info\r\n        for (uint256 i = 0; i < userMemberships[msg.sender].length; i++) {\r\n            if (userMemberships[msg.sender][i].isActive) {\r\n                userMemberships[msg.sender][i].totalContributed += _amount;\r\n                userMemberships[msg.sender][i].lastContribution = block.timestamp;\r\n                userMemberships[msg.sender][i].reputation += 10; // Reputation points\r\n                userMemberships[msg.sender][i].shares += _amount;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Update user reputation\r\n        uint256 oldReputation = userReputation[msg.sender];\r\n        userReputation[msg.sender] += 10;\r\n        emit ReputationUpdated(msg.sender, oldReputation, userReputation[msg.sender]);\r\n        \r\n        // Update next contribution time\r\n        pool.nextContribution = block.timestamp + pool.contributionFrequency * 1 days;\r\n        \r\n        platformStats.totalContributions += _amount;\r\n        \r\n        emit ContributionMade(_poolId, msg.sender, _amount);\r\n        \r\n        // Handle pool-specific logic\r\n        if (pool.poolType == PoolType.ROTATING_SAVINGS) {\r\n            _handleRotatingSavings(_poolId);\r\n        } else if (pool.poolType == PoolType.COLLECTIVE_INVESTMENT) {\r\n            _handleCollectiveInvestment(_poolId);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle rotating savings distribution\r\n     */\r\n    function _handleRotatingSavings(uint256 _poolId) internal {\r\n        Pool storage pool = pools[_poolId];\r\n        \r\n        // Check if it's time for distribution\r\n        if (pool.currentMembers > 0 && pool.poolBalance >= pool.contributionAmount * pool.currentMembers) {\r\n            // Find next member to receive funds\r\n            address[] memory members = _getPoolMembers(_poolId);\r\n            address recipient = members[pool.rotationIndex % members.length];\r\n            \r\n            // Ensure member hasn't received funds yet\r\n            while (pool.hasReceived[recipient] && pool.rotationIndex < members.length * 2) {\r\n                pool.rotationIndex++;\r\n                recipient = members[pool.rotationIndex % members.length];\r\n            }\r\n            \r\n            if (!pool.hasReceived[recipient]) {\r\n                uint256 distributionAmount = pool.contributionAmount * pool.currentMembers;\r\n                pool.poolBalance -= distributionAmount;\r\n                pool.hasReceived[recipient] = true;\r\n                pool.rotationIndex++;\r\n                \r\n                // Transfer funds to recipient\r\n                (bool success, ) = recipient.call{value: distributionAmount}(\"\");\r\n                require(success, \"Transfer failed\");\r\n                \r\n                platformStats.totalDistributions += distributionAmount;\r\n                \r\n                emit FundsDistributed(_poolId, recipient, distributionAmount);\r\n                \r\n                // Check if all members have received funds\r\n                bool allReceived = true;\r\n                for (uint256 i = 0; i < members.length; i++) {\r\n                    if (!pool.hasReceived[members[i]]) {\r\n                        allReceived = false;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                if (allReceived) {\r\n                    pool.isActive = false;\r\n                    emit PoolCompleted(_poolId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle collective investment\r\n     */\r\n    function _handleCollectiveInvestment(uint256 _poolId) internal {\r\n        Pool storage pool = pools[_poolId];\r\n        \r\n        // In production, this would interact with DeFi protocols\r\n        // For now, we just track the balance and calculate yield\r\n        if (pool.poolBalance > 0) {\r\n            // Simulate yield calculation (in production, use real DeFi yields)\r\n            uint256 yieldAmount = (pool.poolBalance * 500) / 10000; // 5% APY\r\n            pool.poolBalance += yieldAmount;\r\n            pool.yieldRate = 500; // 5% in basis points\r\n            \r\n            emit YieldDistributed(_poolId, yieldAmount, block.timestamp);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from pool (for non-rotating pools)\r\n     */\r\n    function withdrawFromPool(uint256 _poolId, uint256 _amount) external onlyPoolMember(_poolId) validAmount(_amount) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.poolType != PoolType.ROTATING_SAVINGS, \"Cannot withdraw from rotating savings\");\r\n        require(pool.poolBalance >= _amount, \"Insufficient pool balance\");\r\n        require(pool.memberContributions[msg.sender] >= _amount, \"Insufficient contribution\");\r\n        \r\n        pool.poolBalance -= _amount;\r\n        pool.memberContributions[msg.sender] -= _amount;\r\n        \r\n        // Transfer funds to user\r\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit FundsDistributed(_poolId, msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Leave pool\r\n     */\r\n    function leavePool(uint256 _poolId) external onlyPoolMember(_poolId) {\r\n        Pool storage pool = pools[_poolId];\r\n        require(pool.poolType != PoolType.ROTATING_SAVINGS, \"Cannot leave rotating savings pool\");\r\n        \r\n        pool.members[msg.sender] = false;\r\n        pool.currentMembers--;\r\n        isMember[msg.sender][_poolId] = false;\r\n        platformStats.totalMembers--;\r\n        \r\n        // Update member status\r\n        for (uint256 i = 0; i < userMemberships[msg.sender].length; i++) {\r\n            if (userMemberships[msg.sender][i].isActive) {\r\n                userMemberships[msg.sender][i].isActive = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        emit MemberLeft(_poolId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Get pool members (simplified - in production, maintain a member list)\r\n     */\r\n    function _getPoolMembers(uint256 _poolId) internal view returns (address[] memory) {\r\n        // This is simplified - in production, maintain a proper member list\r\n        address[] memory members = new address[](0);\r\n        return members;\r\n    }\r\n    \r\n    /**\r\n     * Get pool details\r\n     */\r\n    function getPoolDetails(uint256 _poolId) external view validPoolId(_poolId) returns (\r\n        string memory name,\r\n        string memory description,\r\n        PoolType poolType,\r\n        uint256 contributionAmount,\r\n        uint256 contributionFrequency,\r\n        uint256 maxMembers,\r\n        uint256 currentMembers,\r\n        uint256 totalContributions,\r\n        uint256 poolBalance,\r\n        uint256 yieldRate,\r\n        bool isPublic,\r\n        uint256 createdAt\r\n    ) {\r\n        Pool storage pool = pools[_poolId];\r\n        return (\r\n            pool.name,\r\n            pool.description,\r\n            pool.poolType,\r\n            pool.contributionAmount,\r\n            pool.contributionFrequency,\r\n            pool.maxMembers,\r\n            pool.currentMembers,\r\n            pool.totalContributions,\r\n            pool.poolBalance,\r\n            pool.yieldRate,\r\n            pool.isPublic,\r\n            pool.createdAt\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Get user's pool memberships\r\n     */\r\n    function getUserMemberships(address _user) external view returns (uint256[] memory) {\r\n        uint256[] memory memberships = new uint256[](userMemberships[_user].length);\r\n        uint256 count = 0;\r\n        \r\n        for (uint256 i = 0; i < userMemberships[_user].length; i++) {\r\n            if (userMemberships[_user][i].isActive) {\r\n                memberships[count] = i; // Pool ID would be stored differently in production\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        return memberships;\r\n    }\r\n    \r\n    /**\r\n     * Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalPools,\r\n        uint256 _totalMembers,\r\n        uint256 _totalContributions,\r\n        uint256 _totalDistributions,\r\n        uint256 _averageYield,\r\n        uint256 _platformFeeRate\r\n    ) {\r\n        return (\r\n            platformStats.totalPools,\r\n            platformStats.totalMembers,\r\n            platformStats.totalContributions,\r\n            platformStats.totalDistributions,\r\n            platformStats.averageYield,\r\n            platformFeeRate\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Get user reputation\r\n     */\r\n    function getUserReputation(address _user) external view returns (uint256) {\r\n        return userReputation[_user];\r\n    }\r\n    \r\n    /**\r\n     * Set platform fee rate (only owner)\r\n     */\r\n    function setPlatformFeeRate(uint256 _newRate) external onlyOwner {\r\n        require(_newRate <= 1000, \"Fee rate too high\"); // Max 10%\r\n        platformFeeRate = _newRate;\r\n    }\r\n    \r\n    /**\r\n     * Set reputation threshold (only owner)\r\n     */\r\n    function setReputationThreshold(uint256 _newThreshold) external onlyOwner {\r\n        reputationThreshold = _newThreshold;\r\n    }\r\n    \r\n    /**\r\n     * Withdraw platform fees (only owner)\r\n     */\r\n    function withdrawFees() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        \r\n        (bool success, ) = owner.call{value: balance}(\"\");\r\n        require(success, \"Failed to withdraw fees\");\r\n    }\r\n    \r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/INCLToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n/**\r\n * INCL Token - Governance token for MicroSavings platform\r\n * Enables community governance and fee sharing\r\n * @author SafeNest Team\r\n */\r\ncontract INCLToken {\r\n    // Token details\r\n    string public name = \"Inclusive Finance Token\";\r\n    string public symbol = \"INCL\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n    \r\n    // Owner and platform\r\n    address public immutable owner;\r\n    address public platformContract;\r\n    \r\n    // Balances and allowances\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    \r\n    // Staking for governance\r\n    struct Stake {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        uint256 lockPeriod;\r\n        bool isActive;\r\n    }\r\n    \r\n    mapping(address => Stake[]) public userStakes;\r\n    mapping(address => uint256) public totalStaked;\r\n    \r\n    // Governance\r\n    struct Proposal {\r\n        uint256 id;\r\n        address proposer;\r\n        string title;\r\n        string description;\r\n        uint256 forVotes;\r\n        uint256 againstVotes;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        bool executed;\r\n        bool isActive;\r\n    }\r\n    \r\n    mapping(uint256 => Proposal) public proposals;\r\n    mapping(address => mapping(uint256 => bool)) public hasVoted;\r\n    uint256 public nextProposalId = 1;\r\n    uint256 public votingPowerThreshold = 1000 * 10**18; // 1000 INCL tokens\r\n    uint256 public proposalDuration = 3 days;\r\n    \r\n    // Fee sharing\r\n    uint256 public totalFeesCollected = 0;\r\n    mapping(address => uint256) public userFeeShare;\r\n    uint256 public lastFeeDistribution = 0;\r\n    uint256 public feeDistributionInterval = 7 days;\r\n    \r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event TokensMinted(address indexed to, uint256 amount);\r\n    event TokensBurned(address indexed from, uint256 amount);\r\n    event Staked(address indexed user, uint256 amount, uint256 lockPeriod);\r\n    event Unstaked(address indexed user, uint256 amount);\r\n    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string title);\r\n    event VoteCast(address indexed voter, uint256 indexed proposalId, bool support, uint256 votes);\r\n    event ProposalExecuted(uint256 indexed proposalId);\r\n    event FeeDistributed(address indexed user, uint256 amount);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPlatform() {\r\n        require(msg.sender == platformContract, \"Not the platform contract\");\r\n        _;\r\n    }\r\n    \r\n    modifier validAmount(uint256 _amount) {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n        totalSupply = 1000000000 * 10**18; // 1 billion tokens\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n    \r\n    /**\r\n     * Set platform contract address\r\n     */\r\n    function setPlatformContract(address _platform) external onlyOwner {\r\n        platformContract = _platform;\r\n    }\r\n    \r\n    /**\r\n     * Transfer tokens\r\n     */\r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\r\n        require(_to != address(0), \"Invalid recipient\");\r\n        \r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        \r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Approve spender\r\n     */\r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Transfer from (for allowances)\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\r\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\r\n        require(allowance[_from][msg.sender] >= _value, \"Insufficient allowance\");\r\n        require(_to != address(0), \"Invalid recipient\");\r\n        \r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        \r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Mint tokens (only platform can mint as rewards)\r\n     */\r\n    function mint(address _to, uint256 _amount) external onlyPlatform validAmount(_amount) {\r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit TokensMinted(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Burn tokens\r\n     */\r\n    function burn(uint256 _amount) external validAmount(_amount) {\r\n        require(balanceOf[msg.sender] >= _amount, \"Insufficient balance\");\r\n        \r\n        balanceOf[msg.sender] -= _amount;\r\n        totalSupply -= _amount;\r\n        emit TokensBurned(msg.sender, _amount);\r\n        emit Transfer(msg.sender, address(0), _amount);\r\n    }\r\n    \r\n    /**\r\n     * Stake tokens for governance power\r\n     */\r\n    function stake(uint256 _amount, uint256 _lockPeriod) external validAmount(_amount) {\r\n        require(balanceOf[msg.sender] >= _amount, \"Insufficient balance\");\r\n        require(_lockPeriod >= 30 days, \"Minimum lock period is 30 days\");\r\n        require(_lockPeriod <= 365 days, \"Maximum lock period is 365 days\");\r\n        \r\n        balanceOf[msg.sender] -= _amount;\r\n        totalStaked[msg.sender] += _amount;\r\n        \r\n        userStakes[msg.sender].push(Stake({\r\n            amount: _amount,\r\n            timestamp: block.timestamp,\r\n            lockPeriod: _lockPeriod,\r\n            isActive: true\r\n        }));\r\n        \r\n        emit Staked(msg.sender, _amount, _lockPeriod);\r\n    }\r\n    \r\n    /**\r\n     * Unstake tokens (after lock period)\r\n     */\r\n    function unstake(uint256 _stakeIndex) external {\r\n        require(_stakeIndex < userStakes[msg.sender].length, \"Invalid stake index\");\r\n        \r\n        Stake storage userStake = userStakes[msg.sender][_stakeIndex];\r\n        require(userStake.isActive, \"Stake not active\");\r\n        require(\r\n            block.timestamp >= userStake.timestamp + userStake.lockPeriod,\r\n            \"Stake still locked\"\r\n        );\r\n        \r\n        userStake.isActive = false;\r\n        totalStaked[msg.sender] -= userStake.amount;\r\n        balanceOf[msg.sender] += userStake.amount;\r\n        \r\n        emit Unstaked(msg.sender, userStake.amount);\r\n    }\r\n    \r\n    /**\r\n     * Get user's voting power\r\n     */\r\n    function getVotingPower(address _user) external view returns (uint256) {\r\n        uint256 power = 0;\r\n        \r\n        for (uint256 i = 0; i < userStakes[msg.sender].length; i++) {\r\n            if (userStakes[msg.sender][i].isActive) {\r\n                // Longer lock periods give more voting power\r\n                uint256 multiplier = 100 + (userStakes[msg.sender][i].lockPeriod / 30 days) * 10;\r\n                power += userStakes[msg.sender][i].amount * multiplier / 100;\r\n            }\r\n        }\r\n        \r\n        return power;\r\n    }\r\n    \r\n    /**\r\n     * Create governance proposal\r\n     */\r\n    function createProposal(\r\n        string memory _title,\r\n        string memory _description\r\n    ) external {\r\n        require(totalStaked[msg.sender] >= votingPowerThreshold, \"Insufficient voting power\");\r\n        \r\n        proposals[nextProposalId] = Proposal({\r\n            id: nextProposalId,\r\n            proposer: msg.sender,\r\n            title: _title,\r\n            description: _description,\r\n            forVotes: 0,\r\n            againstVotes: 0,\r\n            startTime: block.timestamp,\r\n            endTime: block.timestamp + proposalDuration,\r\n            executed: false,\r\n            isActive: true\r\n        });\r\n        \r\n        emit ProposalCreated(nextProposalId, msg.sender, _title);\r\n        nextProposalId++;\r\n    }\r\n    \r\n    /**\r\n     * Vote on proposal\r\n     */\r\n    function vote(uint256 _proposalId, bool _support) external {\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        require(proposal.isActive, \"Proposal not active\");\r\n        require(block.timestamp <= proposal.endTime, \"Voting period ended\");\r\n        require(!hasVoted[msg.sender][_proposalId], \"Already voted\");\r\n        \r\n        uint256 votingPower = this.getVotingPower(msg.sender);\r\n        require(votingPower > 0, \"No voting power\");\r\n        \r\n        hasVoted[msg.sender][_proposalId] = true;\r\n        \r\n        if (_support) {\r\n            proposal.forVotes += votingPower;\r\n        } else {\r\n            proposal.againstVotes += votingPower;\r\n        }\r\n        \r\n        emit VoteCast(msg.sender, _proposalId, _support, votingPower);\r\n    }\r\n    \r\n    /**\r\n     * Execute proposal (if passed)\r\n     */\r\n    function executeProposal(uint256 _proposalId) external {\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        require(proposal.isActive, \"Proposal not active\");\r\n        require(block.timestamp > proposal.endTime, \"Voting period not ended\");\r\n        require(!proposal.executed, \"Proposal already executed\");\r\n        require(proposal.forVotes > proposal.againstVotes, \"Proposal not passed\");\r\n        \r\n        proposal.executed = true;\r\n        proposal.isActive = false;\r\n        \r\n        emit ProposalExecuted(_proposalId);\r\n    }\r\n    \r\n    /**\r\n     * Collect platform fees (only platform contract)\r\n     */\r\n    function collectFees(uint256 _amount) external onlyPlatform {\r\n        totalFeesCollected += _amount;\r\n    }\r\n    \r\n    /**\r\n     * Distribute fees to token holders (simplified)\r\n     */\r\n    function distributeFees() external {\r\n        require(\r\n            block.timestamp >= lastFeeDistribution + feeDistributionInterval,\r\n            \"Distribution interval not met\"\r\n        );\r\n        \r\n        // Simplified fee distribution - in production, implement proper staker iteration\r\n        lastFeeDistribution = block.timestamp;\r\n        totalFeesCollected = 0;\r\n    }\r\n    \r\n    /**\r\n     * Claim fee rewards\r\n     */\r\n    function claimFeeRewards() external {\r\n        uint256 rewards = userFeeShare[msg.sender];\r\n        require(rewards > 0, \"No rewards to claim\");\r\n        \r\n        userFeeShare[msg.sender] = 0;\r\n        balanceOf[msg.sender] += rewards;\r\n        \r\n        emit Transfer(address(0), msg.sender, rewards);\r\n    }\r\n    \r\n    /**\r\n     * Get proposal details\r\n     */\r\n    function getProposal(uint256 _proposalId) external view returns (\r\n        address proposer,\r\n        string memory title,\r\n        string memory description,\r\n        uint256 forVotes,\r\n        uint256 againstVotes,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        bool executed,\r\n        bool isActive\r\n    ) {\r\n        Proposal memory proposal = proposals[_proposalId];\r\n        return (\r\n            proposal.proposer,\r\n            proposal.title,\r\n            proposal.description,\r\n            proposal.forVotes,\r\n            proposal.againstVotes,\r\n            proposal.startTime,\r\n            proposal.endTime,\r\n            proposal.executed,\r\n            proposal.isActive\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Get user's staking info\r\n     */\r\n    function getUserStakes(address _user) external view returns (\r\n        uint256 totalStakedAmount,\r\n        uint256 activeStakes,\r\n        uint256 totalVotingPower\r\n    ) {\r\n        totalStakedAmount = totalStaked[_user];\r\n        activeStakes = 0;\r\n        totalVotingPower = 0;\r\n        \r\n        for (uint256 i = 0; i < userStakes[_user].length; i++) {\r\n            if (userStakes[_user][i].isActive) {\r\n                activeStakes++;\r\n                uint256 multiplier = 100 + (userStakes[_user][i].lockPeriod / 30 days) * 10;\r\n                totalVotingPower += userStakes[_user][i].amount * multiplier / 100;\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/InclusiveFinanceFlow.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * InclusiveFinanceFlow - Complete smart contract flow for deposit → yield → pension vault\r\n * Implements the full user journey from micro-savings to retirement planning\r\n * @author SafeNest Team\r\n */\r\ncontract InclusiveFinanceFlow {\r\n    // State Variables\r\n    address public immutable owner;\r\n    string public platformName = \"Inclusive Finance - Complete DeFi Flow\";\r\n    \r\n    // User Account Structure\r\n    struct UserAccount {\r\n        address user;\r\n        uint256 totalDeposited;\r\n        uint256 totalWithdrawn;\r\n        uint256 currentBalance;\r\n        uint256 emergencyFund;\r\n        uint256 pensionFund;\r\n        uint256 communityPoolShares;\r\n        uint256 lastDepositTime;\r\n        uint256 lastWithdrawalTime;\r\n        bool isActive;\r\n        bool hasInsurance;\r\n        bool isPremiumUser;\r\n        uint256 referralCount;\r\n        uint256 totalReferralRewards;\r\n        uint256 educationScore;\r\n        uint256 riskProfile; // 1=Conservative, 2=Moderate, 3=Aggressive\r\n    }\r\n    \r\n    // Pension Vault Structure\r\n    struct PensionVault {\r\n        address user;\r\n        uint256 totalDeposited;\r\n        uint256 currentValue;\r\n        uint256 retirementAge;\r\n        uint256 vestingStartTime;\r\n        uint256 vestingEndTime;\r\n        bool isVesting;\r\n        bool isWithdrawn;\r\n        uint256 monthlyWithdrawalAmount;\r\n        uint256 lastWithdrawalTime;\r\n    }\r\n    \r\n    // Emergency Fund Structure\r\n    struct EmergencyFund {\r\n        address user;\r\n        uint256 balance;\r\n        uint256 lastDepositTime;\r\n        uint256 withdrawalCount;\r\n        uint256 totalWithdrawn;\r\n        bool isActive;\r\n        uint256 incentiveEarned;\r\n    }\r\n    \r\n    // Community Pool Structure\r\n    struct CommunityPool {\r\n        uint256 id;\r\n        address creator;\r\n        string name;\r\n        uint256 totalDeposits;\r\n        uint256 memberCount;\r\n        uint256 yieldRate;\r\n        bool isActive;\r\n        uint256 createdAt;\r\n        mapping(address => uint256) memberShares;\r\n        mapping(address => bool) isMember;\r\n    }\r\n    \r\n    // Yield Strategy Structure\r\n    struct YieldStrategy {\r\n        uint256 id;\r\n        string name;\r\n        address strategyContract;\r\n        uint256 apy;\r\n        uint256 riskLevel; // 1=Low, 2=Medium, 3=High\r\n        bool isActive;\r\n        uint256 minDeposit;\r\n        uint256 maxDeposit;\r\n        uint256 totalDeposited;\r\n        uint256 currentYield;\r\n    }\r\n    \r\n    // Insurance Policy Structure\r\n    struct InsurancePolicy {\r\n        address user;\r\n        uint256 coverageAmount;\r\n        uint256 premiumRate;\r\n        uint256 coverageStartTime;\r\n        uint256 coverageEndTime;\r\n        bool isActive;\r\n        uint256 claimsCount;\r\n        uint256 totalClaimsPaid;\r\n    }\r\n    \r\n    // Referral Structure\r\n    struct ReferralData {\r\n        address referrer;\r\n        address referee;\r\n        uint256 depositAmount;\r\n        uint256 rewardAmount;\r\n        uint256 timestamp;\r\n        bool isPaid;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => UserAccount) public userAccounts;\r\n    mapping(address => PensionVault) public pensionVaults;\r\n    mapping(address => EmergencyFund) public emergencyFunds;\r\n    mapping(uint256 => CommunityPool) public communityPools;\r\n    mapping(uint256 => YieldStrategy) public yieldStrategies;\r\n    mapping(address => InsurancePolicy) public insurancePolicies;\r\n    mapping(address => address) public referrers; // referee => referrer\r\n    mapping(address => ReferralData[]) public referralHistory;\r\n    \r\n    // Platform Statistics\r\n    uint256 public totalUsers = 0;\r\n    uint256 public totalDeposited = 0;\r\n    uint256 public totalWithdrawn = 0;\r\n    uint256 public totalEmergencyFunds = 0;\r\n    uint256 public totalPensionFunds = 0;\r\n    uint256 public totalCommunityPools = 0;\r\n    uint256 public totalInsurancePolicies = 0;\r\n    uint256 public totalReferralRewards = 0;\r\n    \r\n    // Platform Parameters\r\n    uint256 public platformFeeRate = 30; // 0.3%\r\n    uint256 public emergencyWithdrawalFee = 50; // 0.5%\r\n    uint256 public pensionYieldBoost = 200; // 2%\r\n    uint256 public referralBonusRate = 100; // 1%\r\n    uint256 public insurancePremiumRate = 10; // 0.1%\r\n    uint256 public communityPoolYieldBoost = 100; // 1%\r\n    \r\n    // Counters\r\n    uint256 public nextCommunityPoolId = 1;\r\n    uint256 public nextYieldStrategyId = 1;\r\n    \r\n    // Events\r\n    event UserRegistered(address indexed user, address indexed referrer, uint256 timestamp);\r\n    event DepositMade(address indexed user, uint256 amount, uint256 emergencyAmount, uint256 pensionAmount, uint256 timestamp);\r\n    event WithdrawalMade(address indexed user, uint256 amount, uint256 fee, uint256 timestamp);\r\n    event EmergencyWithdrawal(address indexed user, uint256 amount, uint256 fee, uint256 timestamp);\r\n    event PensionDeposit(address indexed user, uint256 amount, uint256 retirementAge, uint256 timestamp);\r\n    event PensionWithdrawal(address indexed user, uint256 amount, uint256 timestamp);\r\n    event CommunityPoolJoined(address indexed user, uint256 poolId, uint256 amount, uint256 timestamp);\r\n    event CommunityPoolCreated(address indexed creator, uint256 poolId, string name, uint256 timestamp);\r\n    event YieldStrategyAdded(uint256 indexed strategyId, string name, uint256 apy, uint256 riskLevel, uint256 timestamp);\r\n    event InsurancePolicyPurchased(address indexed user, uint256 coverageAmount, uint256 premiumRate, uint256 timestamp);\r\n    event InsuranceClaimProcessed(address indexed user, uint256 claimAmount, uint256 timestamp);\r\n    event ReferralRewardPaid(address indexed referrer, address indexed referee, uint256 amount, uint256 timestamp);\r\n    event PremiumFeatureUnlocked(address indexed user, string feature, uint256 timestamp);\r\n    event RiskProfileUpdated(address indexed user, uint256 oldProfile, uint256 newProfile, uint256 timestamp);\r\n    event EducationScoreUpdated(address indexed user, uint256 oldScore, uint256 newScore, uint256 timestamp);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validUser(address _user) {\r\n        require(userAccounts[_user].isActive, \"User not registered\");\r\n        _;\r\n    }\r\n    \r\n    modifier validAmount(uint256 _amount) {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * Register a new user with optional referrer\r\n     */\r\n    function registerUser(address _referrer) external {\r\n        require(!userAccounts[msg.sender].isActive, \"User already registered\");\r\n        \r\n        userAccounts[msg.sender] = UserAccount({\r\n            user: msg.sender,\r\n            totalDeposited: 0,\r\n            totalWithdrawn: 0,\r\n            currentBalance: 0,\r\n            emergencyFund: 0,\r\n            pensionFund: 0,\r\n            communityPoolShares: 0,\r\n            lastDepositTime: 0,\r\n            lastWithdrawalTime: 0,\r\n            isActive: true,\r\n            hasInsurance: false,\r\n            isPremiumUser: false,\r\n            referralCount: 0,\r\n            totalReferralRewards: 0,\r\n            educationScore: 0,\r\n            riskProfile: 1 // Default to conservative\r\n        });\r\n        \r\n        // Set referrer if provided and valid\r\n        if (_referrer != address(0) && _referrer != msg.sender && userAccounts[_referrer].isActive) {\r\n            referrers[msg.sender] = _referrer;\r\n            userAccounts[_referrer].referralCount++;\r\n        }\r\n        \r\n        totalUsers++;\r\n        \r\n        emit UserRegistered(msg.sender, _referrer, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Make a deposit with automatic allocation to emergency fund and pension\r\n     */\r\n    function makeDeposit(\r\n        uint256 _emergencyPercentage, // Percentage for emergency fund (0-100)\r\n        uint256 _pensionPercentage,   // Percentage for pension (0-100)\r\n        uint256 _retirementAge        // Retirement age for pension (60-75)\r\n    ) external payable validUser(msg.sender) validAmount(msg.value) {\r\n        require(_emergencyPercentage + _pensionPercentage <= 100, \"Percentages exceed 100%\");\r\n        require(_retirementAge >= 60 && _retirementAge <= 75, \"Invalid retirement age\");\r\n        \r\n        uint256 totalAmount = msg.value;\r\n        uint256 emergencyAmount = (totalAmount * _emergencyPercentage) / 100;\r\n        uint256 pensionAmount = (totalAmount * _pensionPercentage) / 100;\r\n        uint256 savingsAmount = totalAmount - emergencyAmount - pensionAmount;\r\n        \r\n        // Update user account\r\n        UserAccount storage account = userAccounts[msg.sender];\r\n        account.totalDeposited += totalAmount;\r\n        account.currentBalance += savingsAmount;\r\n        account.lastDepositTime = block.timestamp;\r\n        \r\n        // Handle emergency fund\r\n        if (emergencyAmount > 0) {\r\n            if (!emergencyFunds[msg.sender].isActive) {\r\n                emergencyFunds[msg.sender] = EmergencyFund({\r\n                    user: msg.sender,\r\n                    balance: 0,\r\n                    lastDepositTime: 0,\r\n                    withdrawalCount: 0,\r\n                    totalWithdrawn: 0,\r\n                    isActive: true,\r\n                    incentiveEarned: 0\r\n                });\r\n            }\r\n            emergencyFunds[msg.sender].balance += emergencyAmount;\r\n            emergencyFunds[msg.sender].lastDepositTime = block.timestamp;\r\n            account.emergencyFund += emergencyAmount;\r\n            totalEmergencyFunds += emergencyAmount;\r\n        }\r\n        \r\n        // Handle pension fund\r\n        if (pensionAmount > 0) {\r\n            if (pensionVaults[msg.sender].vestingStartTime == 0) {\r\n                pensionVaults[msg.sender] = PensionVault({\r\n                    user: msg.sender,\r\n                    totalDeposited: 0,\r\n                    currentValue: 0,\r\n                    retirementAge: _retirementAge,\r\n                    vestingStartTime: block.timestamp,\r\n                    vestingEndTime: block.timestamp + (10 * 365 days), // 10-year vesting\r\n                    isVesting: true,\r\n                    isWithdrawn: false,\r\n                    monthlyWithdrawalAmount: 0,\r\n                    lastWithdrawalTime: 0\r\n                });\r\n            }\r\n            pensionVaults[msg.sender].totalDeposited += pensionAmount;\r\n            pensionVaults[msg.sender].currentValue += pensionAmount;\r\n            account.pensionFund += pensionAmount;\r\n            totalPensionFunds += pensionAmount;\r\n            \r\n            emit PensionDeposit(msg.sender, pensionAmount, _retirementAge, block.timestamp);\r\n        }\r\n        \r\n        // Process referral reward\r\n        if (referrers[msg.sender] != address(0)) {\r\n            uint256 referralReward = (totalAmount * referralBonusRate) / 10000;\r\n            address referrer = referrers[msg.sender];\r\n            \r\n            userAccounts[referrer].totalReferralRewards += referralReward;\r\n            totalReferralRewards += referralReward;\r\n            \r\n            referralHistory[referrer].push(ReferralData({\r\n                referrer: referrer,\r\n                referee: msg.sender,\r\n                depositAmount: totalAmount,\r\n                rewardAmount: referralReward,\r\n                timestamp: block.timestamp,\r\n                isPaid: false\r\n            }));\r\n            \r\n            emit ReferralRewardPaid(referrer, msg.sender, referralReward, block.timestamp);\r\n        }\r\n        \r\n        totalDeposited += totalAmount;\r\n        \r\n        emit DepositMade(msg.sender, totalAmount, emergencyAmount, pensionAmount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from regular savings\r\n     */\r\n    function withdrawSavings(uint256 _amount) external validUser(msg.sender) validAmount(_amount) {\r\n        UserAccount storage account = userAccounts[msg.sender];\r\n        require(account.currentBalance >= _amount, \"Insufficient balance\");\r\n        \r\n        account.currentBalance -= _amount;\r\n        account.totalWithdrawn += _amount;\r\n        account.lastWithdrawalTime = block.timestamp;\r\n        \r\n        totalWithdrawn += _amount;\r\n        \r\n        // Transfer ETH to user\r\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit WithdrawalMade(msg.sender, _amount, 0, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Emergency withdrawal with fee\r\n     */\r\n    function emergencyWithdrawal(uint256 _amount) external validUser(msg.sender) validAmount(_amount) {\r\n        EmergencyFund storage emergency = emergencyFunds[msg.sender];\r\n        require(emergency.isActive, \"No emergency fund\");\r\n        require(emergency.balance >= _amount, \"Insufficient emergency balance\");\r\n        \r\n        uint256 fee = (_amount * emergencyWithdrawalFee) / 10000;\r\n        uint256 netAmount = _amount - fee;\r\n        \r\n        emergency.balance -= _amount;\r\n        emergency.withdrawalCount++;\r\n        emergency.totalWithdrawn += _amount;\r\n        \r\n        userAccounts[msg.sender].emergencyFund -= _amount;\r\n        totalEmergencyFunds -= _amount;\r\n        \r\n        // Transfer net amount to user\r\n        (bool success, ) = msg.sender.call{value: netAmount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit EmergencyWithdrawal(msg.sender, _amount, fee, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from pension vault (only after retirement age and vesting period)\r\n     */\r\n    function withdrawPension(uint256 _amount) external validUser(msg.sender) validAmount(_amount) {\r\n        PensionVault storage pension = pensionVaults[msg.sender];\r\n        require(pension.isVesting, \"No pension vault\");\r\n        require(!pension.isWithdrawn, \"Pension already withdrawn\");\r\n        require(block.timestamp >= pension.vestingEndTime, \"Vesting period not completed\");\r\n        \r\n        // Check retirement age (simplified - in production, use oracle for age verification)\r\n        require(block.timestamp >= pension.vestingStartTime + (pension.retirementAge * 365 days), \"Not retirement age\");\r\n        \r\n        require(pension.currentValue >= _amount, \"Insufficient pension balance\");\r\n        \r\n        pension.currentValue -= _amount;\r\n        pension.lastWithdrawalTime = block.timestamp;\r\n        \r\n        userAccounts[msg.sender].pensionFund -= _amount;\r\n        totalPensionFunds -= _amount;\r\n        \r\n        // Transfer to user\r\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit PensionWithdrawal(msg.sender, _amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Create a community pool (digital chama)\r\n     */\r\n    function createCommunityPool(string memory _name) external validUser(msg.sender) {\r\n        CommunityPool storage pool = communityPools[nextCommunityPoolId];\r\n        pool.id = nextCommunityPoolId;\r\n        pool.creator = msg.sender;\r\n        pool.name = _name;\r\n        pool.totalDeposits = 0;\r\n        pool.memberCount = 0;\r\n        pool.yieldRate = 0;\r\n        pool.isActive = true;\r\n        pool.createdAt = block.timestamp;\r\n        \r\n        // Creator automatically becomes first member\r\n        pool.isMember[msg.sender] = true;\r\n        pool.memberCount = 1;\r\n        \r\n        totalCommunityPools++;\r\n        \r\n        emit CommunityPoolCreated(msg.sender, nextCommunityPoolId, _name, block.timestamp);\r\n        nextCommunityPoolId++;\r\n    }\r\n    \r\n    /**\r\n     * Join a community pool\r\n     */\r\n    function joinCommunityPool(uint256 _poolId, uint256 _amount) external payable validUser(msg.sender) validAmount(_amount) {\r\n        require(msg.value >= _amount, \"Insufficient ETH sent\");\r\n        require(_poolId < nextCommunityPoolId, \"Invalid pool ID\");\r\n        \r\n        CommunityPool storage pool = communityPools[_poolId];\r\n        require(pool.isActive, \"Pool not active\");\r\n        require(!pool.isMember[msg.sender], \"Already a member\");\r\n        require(pool.memberCount < 50, \"Pool is full\");\r\n        \r\n        pool.isMember[msg.sender] = true;\r\n        pool.memberShares[msg.sender] = _amount;\r\n        pool.totalDeposits += _amount;\r\n        pool.memberCount++;\r\n        \r\n        userAccounts[msg.sender].communityPoolShares += _amount;\r\n        \r\n        emit CommunityPoolJoined(msg.sender, _poolId, _amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Purchase insurance policy\r\n     */\r\n    function purchaseInsurance(uint256 _coverageAmount) external validUser(msg.sender) validAmount(_coverageAmount) {\r\n        require(!insurancePolicies[msg.sender].isActive, \"Insurance already active\");\r\n        \r\n        insurancePolicies[msg.sender] = InsurancePolicy({\r\n            user: msg.sender,\r\n            coverageAmount: _coverageAmount,\r\n            premiumRate: insurancePremiumRate,\r\n            coverageStartTime: block.timestamp,\r\n            coverageEndTime: block.timestamp + (365 days), // 1 year coverage\r\n            isActive: true,\r\n            claimsCount: 0,\r\n            totalClaimsPaid: 0\r\n        });\r\n        \r\n        userAccounts[msg.sender].hasInsurance = true;\r\n        totalInsurancePolicies++;\r\n        \r\n        emit InsurancePolicyPurchased(msg.sender, _coverageAmount, insurancePremiumRate, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Update user risk profile\r\n     */\r\n    function updateRiskProfile(uint256 _newProfile) external validUser(msg.sender) {\r\n        require(_newProfile >= 1 && _newProfile <= 3, \"Invalid risk profile\");\r\n        \r\n        uint256 oldProfile = userAccounts[msg.sender].riskProfile;\r\n        userAccounts[msg.sender].riskProfile = _newProfile;\r\n        \r\n        emit RiskProfileUpdated(msg.sender, oldProfile, _newProfile, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Update education score (called by education system)\r\n     */\r\n    function updateEducationScore(address _user, uint256 _newScore) external onlyOwner {\r\n        require(userAccounts[_user].isActive, \"User not registered\");\r\n        \r\n        uint256 oldScore = userAccounts[_user].educationScore;\r\n        userAccounts[_user].educationScore = _newScore;\r\n        \r\n        // Unlock premium features based on education score\r\n        if (_newScore >= 100 && !userAccounts[_user].isPremiumUser) {\r\n            userAccounts[_user].isPremiumUser = true;\r\n            emit PremiumFeatureUnlocked(_user, \"Premium User\", block.timestamp);\r\n        }\r\n        \r\n        emit EducationScoreUpdated(_user, oldScore, _newScore, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Get user's complete portfolio\r\n     */\r\n    function getUserPortfolio(address _user) external view returns (\r\n        uint256 totalBalance,\r\n        uint256 emergencyFund,\r\n        uint256 pensionFund,\r\n        uint256 communityShares,\r\n        uint256 referralRewards,\r\n        uint256 educationScore,\r\n        uint256 riskProfile,\r\n        bool hasInsurance,\r\n        bool isPremiumUser\r\n    ) {\r\n        UserAccount memory account = userAccounts[_user];\r\n        EmergencyFund memory emergency = emergencyFunds[_user];\r\n        PensionVault memory pension = pensionVaults[_user];\r\n        \r\n        return (\r\n            account.currentBalance,\r\n            emergency.balance,\r\n            pension.currentValue,\r\n            account.communityPoolShares,\r\n            account.totalReferralRewards,\r\n            account.educationScore,\r\n            account.riskProfile,\r\n            account.hasInsurance,\r\n            account.isPremiumUser\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalUsers,\r\n        uint256 _totalDeposited,\r\n        uint256 _totalWithdrawn,\r\n        uint256 _totalEmergencyFunds,\r\n        uint256 _totalPensionFunds,\r\n        uint256 _totalCommunityPools,\r\n        uint256 _totalInsurancePolicies,\r\n        uint256 _totalReferralRewards\r\n    ) {\r\n        return (\r\n            totalUsers,\r\n            totalDeposited,\r\n            totalWithdrawn,\r\n            totalEmergencyFunds,\r\n            totalPensionFunds,\r\n            totalCommunityPools,\r\n            totalInsurancePolicies,\r\n            totalReferralRewards\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Owner functions for platform management\r\n     */\r\n    function setPlatformFeeRate(uint256 _newRate) external onlyOwner {\r\n        require(_newRate <= 1000, \"Fee rate too high\");\r\n        platformFeeRate = _newRate;\r\n    }\r\n    \r\n    function setEmergencyWithdrawalFee(uint256 _newFee) external onlyOwner {\r\n        require(_newFee <= 1000, \"Fee too high\");\r\n        emergencyWithdrawalFee = _newFee;\r\n    }\r\n    \r\n    function setReferralBonusRate(uint256 _newRate) external onlyOwner {\r\n        require(_newRate <= 1000, \"Rate too high\");\r\n        referralBonusRate = _newRate;\r\n    }\r\n    \r\n    function withdrawPlatformFees() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        \r\n        (bool success, ) = owner.call{value: balance}(\"\");\r\n        require(success, \"Failed to withdraw fees\");\r\n    }\r\n    \r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/InclusiveFinanceTokenomics.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * InclusiveFinanceTokenomics - Comprehensive tokenomics for $INCL governance token\r\n * Implements the complete economic model for the Inclusive Finance DApp\r\n * @author SafeNest Team\r\n */\r\ncontract InclusiveFinanceTokenomics {\r\n    // Token Details\r\n    string public constant name = \"Inclusive Finance Token\";\r\n    string public constant symbol = \"INCL\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 * 10**18; // 1 billion tokens\r\n    \r\n    // Token Distribution (Total: 1B tokens)\r\n    uint256 public constant COMMUNITY_ALLOCATION = 400_000_000 * 10**18; // 40% - Community rewards, referrals\r\n    uint256 public constant TEAM_ALLOCATION = 150_000_000 * 10**18; // 15% - Team (4-year vesting)\r\n    uint256 public constant TREASURY_ALLOCATION = 200_000_000 * 10**18; // 20% - Protocol treasury\r\n    uint256 public constant LIQUIDITY_ALLOCATION = 100_000_000 * 10**18; // 10% - DEX liquidity\r\n    uint256 public constant PARTNERS_ALLOCATION = 100_000_000 * 10**18; // 10% - Strategic partners\r\n    uint256 public constant EARLY_ADOPTERS = 50_000_000 * 10**18; // 5% - Early users & testers\r\n    \r\n    // Staking Rewards\r\n    uint256 public constant STAKING_REWARDS_POOL = 300_000_000 * 10**18; // 30% of total supply for staking rewards\r\n    uint256 public constant REWARDS_DURATION = 4 * 365 days; // 4 years of rewards\r\n    uint256 public constant REWARDS_PER_SECOND = STAKING_REWARDS_POOL / REWARDS_DURATION;\r\n    \r\n    // Fee Structure\r\n    uint256 public constant PROTOCOL_FEE_RATE = 30; // 0.3% in basis points\r\n    uint256 public constant STAKING_FEE_SHARE = 50; // 50% of fees go to stakers\r\n    uint256 public constant TREASURY_FEE_SHARE = 30; // 30% to treasury\r\n    uint256 public constant BURN_FEE_SHARE = 20; // 20% burned (deflationary)\r\n    \r\n    // Governance Parameters\r\n    uint256 public constant MIN_STAKE_FOR_VOTING = 1000 * 10**18; // 1000 INCL minimum stake\r\n    uint256 public constant VOTING_DURATION = 3 days;\r\n    uint256 public constant EXECUTION_DELAY = 1 days;\r\n    uint256 public constant QUORUM_THRESHOLD = 5; // 5% of total staked tokens\r\n    \r\n    // Referral System\r\n    uint256 public constant REFERRAL_BONUS_RATE = 100; // 1% of referred user's deposits\r\n    uint256 public constant REFERRAL_DURATION = 365 days; // 1 year of referral rewards\r\n    uint256 public constant MAX_REFERRAL_DEPTH = 3; // 3 levels deep\r\n    \r\n    // Pension Vault Parameters\r\n    uint256 public constant MIN_PENSION_AGE = 60; // Minimum retirement age\r\n    uint256 public constant MAX_PENSION_AGE = 75; // Maximum retirement age\r\n    uint256 public constant PENSION_VESTING_PERIOD = 10 * 365 days; // 10-year vesting\r\n    uint256 public constant PENSION_YIELD_BOOST = 200; // 2% additional yield for pension deposits\r\n    \r\n    // Emergency Fund Parameters\r\n    uint256 public constant EMERGENCY_WITHDRAWAL_FEE = 50; // 0.5% fee for instant withdrawal\r\n    uint256 public constant EMERGENCY_INCENTIVE_RATE = 25; // 0.25% bonus for keeping funds parked\r\n    \r\n    // Mobile Money Integration\r\n    uint256 public constant ROUND_UP_MIN_AMOUNT = 1 * 10**18; // 1 USDC minimum round-up\r\n    uint256 public constant ROUND_UP_MAX_AMOUNT = 10 * 10**18; // 10 USDC maximum round-up\r\n    uint256 public constant MOBILE_MONEY_FEE = 20; // 0.2% fee for mobile money integration\r\n    \r\n    // Insurance Parameters\r\n    uint256 public constant INSURANCE_PREMIUM_RATE = 10; // 0.1% of yield for insurance\r\n    uint256 public constant INSURANCE_COVERAGE_RATE = 1000; // 10x coverage for insured deposits\r\n    \r\n    // Community Pool Parameters\r\n    uint256 public constant CHAMA_MIN_MEMBERS = 5;\r\n    uint256 public constant CHAMA_MAX_MEMBERS = 50;\r\n    uint256 public constant CHAMA_YIELD_BOOST = 100; // 1% additional yield for community pools\r\n    \r\n    // Inflation Protection\r\n    uint256 public constant INFLATION_ADJUSTMENT_PERIOD = 30 days;\r\n    uint256 public constant INFLATION_THRESHOLD = 500; // 5% inflation threshold\r\n    \r\n    // Cross-Border Transfer\r\n    uint256 public constant CROSS_BORDER_FEE = 100; // 1% fee for cross-border transfers\r\n    uint256 public constant CROSS_BORDER_MIN_AMOUNT = 100 * 10**18; // 100 USDC minimum\r\n    \r\n    // Premium Features (requires staking)\r\n    uint256 public constant PREMIUM_WITHDRAWAL_STAKE = 10000 * 10**18; // 10k INCL for instant withdrawal\r\n    uint256 public constant PREMIUM_TRANSFER_STAKE = 5000 * 10**18; // 5k INCL for free transfers\r\n    uint256 public constant PREMIUM_INSURANCE_STAKE = 20000 * 10**18; // 20k INCL for premium insurance\r\n    \r\n    // Yield Strategy Allocation\r\n    uint256 public constant CONSERVATIVE_ALLOCATION = 60; // 60% in low-risk strategies\r\n    uint256 public constant MODERATE_ALLOCATION = 30; // 30% in moderate-risk strategies\r\n    uint256 public constant AGGRESSIVE_ALLOCATION = 10; // 10% in higher-risk strategies\r\n    \r\n    // Risk Management\r\n    uint256 public constant MAX_SINGLE_DEPOSIT = 10000 * 10**18; // 10k USDC max single deposit\r\n    uint256 public constant MAX_DAILY_DEPOSIT = 50000 * 10**18; // 50k USDC max daily deposit\r\n    uint256 public constant MAX_TOTAL_EXPOSURE = 1000000 * 10**18; // 1M USDC max total exposure\r\n    \r\n    // Liquidity Mining\r\n    uint256 public constant LIQUIDITY_MINING_REWARDS = 50_000_000 * 10**18; // 50M tokens for liquidity mining\r\n    uint256 public constant LIQUIDITY_MINING_DURATION = 2 * 365 days; // 2 years\r\n    uint256 public constant LIQUIDITY_MINING_RATE = LIQUIDITY_MINING_REWARDS / LIQUIDITY_MINING_DURATION;\r\n    \r\n    // Educational Rewards\r\n    uint256 public constant EDUCATION_REWARDS = 25_000_000 * 10**18; // 25M tokens for financial education\r\n    uint256 public constant EDUCATION_COMPLETION_BONUS = 100 * 10**18; // 100 INCL per completed module\r\n    \r\n    // Partnership Rewards\r\n    uint256 public constant PARTNER_REWARDS = 75_000_000 * 10**18; // 75M tokens for partner integrations\r\n    uint256 public constant PARTNER_REFERRAL_BONUS = 500 * 10**18; // 500 INCL per partner referral\r\n    \r\n    // Events\r\n    event TokenomicsInitialized(uint256 totalSupply, uint256 timestamp);\r\n    event StakingRewardsUpdated(uint256 newRate, uint256 timestamp);\r\n    event FeeStructureUpdated(uint256 protocolFee, uint256 stakingShare, uint256 timestamp);\r\n    event ReferralBonusPaid(address referrer, address referee, uint256 amount, uint256 timestamp);\r\n    event PensionDepositMade(address user, uint256 amount, uint256 retirementAge, uint256 timestamp);\r\n    event EmergencyFundWithdrawal(address user, uint256 amount, uint256 fee, uint256 timestamp);\r\n    event CommunityPoolCreated(address creator, uint256 poolId, uint256 memberCount, uint256 timestamp);\r\n    event InsuranceClaimProcessed(address user, uint256 claimAmount, uint256 timestamp);\r\n    event CrossBorderTransfer(address from, address to, uint256 amount, uint256 fee, uint256 timestamp);\r\n    event PremiumFeatureUnlocked(address user, string feature, uint256 stakeAmount, uint256 timestamp);\r\n    event LiquidityMiningReward(address user, uint256 amount, uint256 timestamp);\r\n    event EducationRewardEarned(address user, string module, uint256 reward, uint256 timestamp);\r\n    event PartnerRewardDistributed(address partner, uint256 amount, uint256 timestamp);\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        emit TokenomicsInitialized(TOTAL_SUPPLY, block.timestamp);\r\n    }\r\n    \r\n    // View functions for tokenomics parameters\r\n    function getTokenomicsSummary() external pure returns (\r\n        uint256 totalSupply,\r\n        uint256 communityAllocation,\r\n        uint256 stakingRewardsPool,\r\n        uint256 protocolFeeRate,\r\n        uint256 minStakeForVoting,\r\n        uint256 referralBonusRate\r\n    ) {\r\n        return (\r\n            TOTAL_SUPPLY,\r\n            COMMUNITY_ALLOCATION,\r\n            STAKING_REWARDS_POOL,\r\n            PROTOCOL_FEE_RATE,\r\n            MIN_STAKE_FOR_VOTING,\r\n            REFERRAL_BONUS_RATE\r\n        );\r\n    }\r\n    \r\n    function getFeeStructure() external pure returns (\r\n        uint256 protocolFee,\r\n        uint256 stakingShare,\r\n        uint256 treasuryShare,\r\n        uint256 burnShare\r\n    ) {\r\n        return (\r\n            PROTOCOL_FEE_RATE,\r\n            STAKING_FEE_SHARE,\r\n            TREASURY_FEE_SHARE,\r\n            BURN_FEE_SHARE\r\n        );\r\n    }\r\n    \r\n    function getPensionParameters() external pure returns (\r\n        uint256 minAge,\r\n        uint256 maxAge,\r\n        uint256 vestingPeriod,\r\n        uint256 yieldBoost\r\n    ) {\r\n        return (\r\n            MIN_PENSION_AGE,\r\n            MAX_PENSION_AGE,\r\n            PENSION_VESTING_PERIOD,\r\n            PENSION_YIELD_BOOST\r\n        );\r\n    }\r\n    \r\n    function getEmergencyFundParameters() external pure returns (\r\n        uint256 withdrawalFee,\r\n        uint256 incentiveRate\r\n    ) {\r\n        return (\r\n            EMERGENCY_WITHDRAWAL_FEE,\r\n            EMERGENCY_INCENTIVE_RATE\r\n        );\r\n    }\r\n    \r\n    function getMobileMoneyParameters() external pure returns (\r\n        uint256 minRoundUp,\r\n        uint256 maxRoundUp,\r\n        uint256 integrationFee\r\n    ) {\r\n        return (\r\n            ROUND_UP_MIN_AMOUNT,\r\n            ROUND_UP_MAX_AMOUNT,\r\n            MOBILE_MONEY_FEE\r\n        );\r\n    }\r\n    \r\n    function getInsuranceParameters() external pure returns (\r\n        uint256 premiumRate,\r\n        uint256 coverageRate\r\n    ) {\r\n        return (\r\n            INSURANCE_PREMIUM_RATE,\r\n            INSURANCE_COVERAGE_RATE\r\n        );\r\n    }\r\n    \r\n    function getCommunityPoolParameters() external pure returns (\r\n        uint256 minMembers,\r\n        uint256 maxMembers,\r\n        uint256 yieldBoost\r\n    ) {\r\n        return (\r\n            CHAMA_MIN_MEMBERS,\r\n            CHAMA_MAX_MEMBERS,\r\n            CHAMA_YIELD_BOOST\r\n        );\r\n    }\r\n    \r\n    function getPremiumFeatureRequirements() external pure returns (\r\n        uint256 instantWithdrawalStake,\r\n        uint256 freeTransferStake,\r\n        uint256 premiumInsuranceStake\r\n    ) {\r\n        return (\r\n            PREMIUM_WITHDRAWAL_STAKE,\r\n            PREMIUM_TRANSFER_STAKE,\r\n            PREMIUM_INSURANCE_STAKE\r\n        );\r\n    }\r\n    \r\n    function getRiskManagementParameters() external pure returns (\r\n        uint256 maxSingleDeposit,\r\n        uint256 maxDailyDeposit,\r\n        uint256 maxTotalExposure\r\n    ) {\r\n        return (\r\n            MAX_SINGLE_DEPOSIT,\r\n            MAX_DAILY_DEPOSIT,\r\n            MAX_TOTAL_EXPOSURE\r\n        );\r\n    }\r\n    \r\n    function getRewardPools() external pure returns (\r\n        uint256 liquidityMiningRewards,\r\n        uint256 educationRewards,\r\n        uint256 partnerRewards\r\n    ) {\r\n        return (\r\n            LIQUIDITY_MINING_REWARDS,\r\n            EDUCATION_REWARDS,\r\n            PARTNER_REWARDS\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/MicroSavings.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n/**\r\n * MicroSavings - Mobile-first DeFi savings and investment platform\r\n * Enables micro-savings, micro-investments, and on-chain micro-pensions\r\n * @author SafeNest Team\r\n */\r\ncontract MicroSavings {\r\n    // State Variables\r\n    address public immutable owner;\r\n    string public platformName = \"MicroSavings - Mobile DeFi Platform\";\r\n    \r\n    // Supported stablecoins\r\n    mapping(address => bool) public supportedStablecoins;\r\n    mapping(address => uint256) public stablecoinDecimals;\r\n    \r\n    // User savings accounts\r\n    struct SavingsAccount {\r\n        address user;\r\n        address stablecoin;\r\n        uint256 totalDeposited;\r\n        uint256 totalWithdrawn;\r\n        uint256 currentBalance;\r\n        uint256 lastDepositTime;\r\n        bool isActive;\r\n    }\r\n    \r\n    // Investment strategies\r\n    struct InvestmentStrategy {\r\n        string name;\r\n        address strategyContract;\r\n        uint256 apy; // Annual percentage yield in basis points (100 = 1%)\r\n        bool isActive;\r\n        uint256 minDeposit;\r\n        uint256 maxDeposit;\r\n    }\r\n    \r\n    // User investment positions\r\n    struct InvestmentPosition {\r\n        address user;\r\n        uint256 strategyId;\r\n        address stablecoin;\r\n        uint256 amount;\r\n        uint256 shares;\r\n        uint256 entryTime;\r\n        bool isActive;\r\n    }\r\n    \r\n    // Emergency fund vault\r\n    struct EmergencyVault {\r\n        address user;\r\n        address stablecoin;\r\n        uint256 balance;\r\n        uint256 lastDepositTime;\r\n        uint256 withdrawalCount;\r\n        bool isActive;\r\n    }\r\n    \r\n    // Goal tracking\r\n    struct SavingsGoal {\r\n        address user;\r\n        string goalName;\r\n        uint256 targetAmount;\r\n        uint256 currentAmount;\r\n        uint256 deadline;\r\n        bool isCompleted;\r\n        uint256 createdAt;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => SavingsAccount) public userSavingsAccounts;\r\n    mapping(address => mapping(address => uint256)) public userStablecoinBalances;\r\n    mapping(uint256 => InvestmentStrategy) public investmentStrategies;\r\n    mapping(address => InvestmentPosition[]) public userInvestments;\r\n    mapping(address => EmergencyVault) public userEmergencyVaults;\r\n    mapping(address => SavingsGoal[]) public userGoals;\r\n    \r\n    // Platform statistics\r\n    uint256 public totalUsers = 0;\r\n    uint256 public totalDeposited = 0;\r\n    uint256 public totalInvested = 0;\r\n    uint256 public totalEmergencyFunds = 0;\r\n    uint256 public platformFeeRate = 30; // 0.3% in basis points\r\n    uint256 public nextStrategyId = 1;\r\n    \r\n    // Events\r\n    event StablecoinAdded(address indexed stablecoin, uint256 decimals);\r\n    event DepositMade(address indexed user, address indexed stablecoin, uint256 amount);\r\n    event WithdrawalMade(address indexed user, address indexed stablecoin, uint256 amount);\r\n    event InvestmentMade(address indexed user, uint256 strategyId, uint256 amount);\r\n    event InvestmentWithdrawn(address indexed user, uint256 strategyId, uint256 amount);\r\n    event EmergencyDeposit(address indexed user, address indexed stablecoin, uint256 amount);\r\n    event EmergencyWithdrawal(address indexed user, address indexed stablecoin, uint256 amount);\r\n    event GoalCreated(address indexed user, string goalName, uint256 targetAmount);\r\n    event GoalUpdated(address indexed user, string goalName, uint256 currentAmount);\r\n    event GoalCompleted(address indexed user, string goalName);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validStablecoin(address _stablecoin) {\r\n        require(supportedStablecoins[_stablecoin], \"Unsupported stablecoin\");\r\n        _;\r\n    }\r\n    \r\n    modifier validAmount(uint256 _amount) {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * Add supported stablecoin\r\n     */\r\n    function addStablecoin(address _stablecoin, uint256 _decimals) external onlyOwner {\r\n        supportedStablecoins[_stablecoin] = true;\r\n        stablecoinDecimals[_stablecoin] = _decimals;\r\n        emit StablecoinAdded(_stablecoin, _decimals);\r\n    }\r\n    \r\n    /**\r\n     * Add investment strategy\r\n     */\r\n    function addInvestmentStrategy(\r\n        string memory _name,\r\n        address _strategyContract,\r\n        uint256 _apy,\r\n        uint256 _minDeposit,\r\n        uint256 _maxDeposit\r\n    ) external onlyOwner {\r\n        investmentStrategies[nextStrategyId] = InvestmentStrategy({\r\n            name: _name,\r\n            strategyContract: _strategyContract,\r\n            apy: _apy,\r\n            isActive: true,\r\n            minDeposit: _minDeposit,\r\n            maxDeposit: _maxDeposit\r\n        });\r\n        nextStrategyId++;\r\n    }\r\n    \r\n    /**\r\n     * Make micro-savings deposit\r\n     */\r\n    function depositSavings(\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    ) external validStablecoin(_stablecoin) validAmount(_amount) {\r\n        // Transfer stablecoin from user\r\n        // Note: In production, you'd use IERC20(_stablecoin).transferFrom(msg.sender, address(this), _amount)\r\n        \r\n        // Update user savings account\r\n        if (!userSavingsAccounts[msg.sender].isActive) {\r\n            userSavingsAccounts[msg.sender] = SavingsAccount({\r\n                user: msg.sender,\r\n                stablecoin: _stablecoin,\r\n                totalDeposited: 0,\r\n                totalWithdrawn: 0,\r\n                currentBalance: 0,\r\n                lastDepositTime: 0,\r\n                isActive: true\r\n            });\r\n            totalUsers++;\r\n        }\r\n        \r\n        userSavingsAccounts[msg.sender].totalDeposited += _amount;\r\n        userSavingsAccounts[msg.sender].currentBalance += _amount;\r\n        userSavingsAccounts[msg.sender].lastDepositTime = block.timestamp;\r\n        userStablecoinBalances[msg.sender][_stablecoin] += _amount;\r\n        \r\n        totalDeposited += _amount;\r\n        \r\n        emit DepositMade(msg.sender, _stablecoin, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from savings\r\n     */\r\n    function withdrawSavings(\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    ) external validStablecoin(_stablecoin) validAmount(_amount) {\r\n        require(\r\n            userStablecoinBalances[msg.sender][_stablecoin] >= _amount,\r\n            \"Insufficient balance\"\r\n        );\r\n        \r\n        userSavingsAccounts[msg.sender].totalWithdrawn += _amount;\r\n        userSavingsAccounts[msg.sender].currentBalance -= _amount;\r\n        userStablecoinBalances[msg.sender][_stablecoin] -= _amount;\r\n        \r\n        totalDeposited -= _amount;\r\n        \r\n        // Transfer stablecoin to user\r\n        // Note: In production, you'd use IERC20(_stablecoin).transfer(msg.sender, _amount)\r\n        \r\n        emit WithdrawalMade(msg.sender, _stablecoin, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Invest in DeFi strategy\r\n     */\r\n    function investInStrategy(\r\n        uint256 _strategyId,\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    ) external validStablecoin(_stablecoin) validAmount(_amount) {\r\n        InvestmentStrategy storage strategy = investmentStrategies[_strategyId];\r\n        require(strategy.isActive, \"Strategy not active\");\r\n        require(_amount >= strategy.minDeposit, \"Amount below minimum\");\r\n        require(_amount <= strategy.maxDeposit, \"Amount above maximum\");\r\n        require(\r\n            userStablecoinBalances[msg.sender][_stablecoin] >= _amount,\r\n            \"Insufficient balance\"\r\n        );\r\n        \r\n        // Calculate shares (simplified - in production, use proper share calculation)\r\n        uint256 shares = _amount * 1e18 / 1e18; // 1:1 for simplicity\r\n        \r\n        userInvestments[msg.sender].push(InvestmentPosition({\r\n            user: msg.sender,\r\n            strategyId: _strategyId,\r\n            stablecoin: _stablecoin,\r\n            amount: _amount,\r\n            shares: shares,\r\n            entryTime: block.timestamp,\r\n            isActive: true\r\n        }));\r\n        \r\n        userStablecoinBalances[msg.sender][_stablecoin] -= _amount;\r\n        totalInvested += _amount;\r\n        \r\n        emit InvestmentMade(msg.sender, _strategyId, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from investment\r\n     */\r\n    function withdrawFromInvestment(\r\n        uint256 _positionIndex,\r\n        uint256 _shares\r\n    ) external validAmount(_shares) {\r\n        require(\r\n            _positionIndex < userInvestments[msg.sender].length,\r\n            \"Invalid position index\"\r\n        );\r\n        \r\n        InvestmentPosition storage position = userInvestments[msg.sender][_positionIndex];\r\n        require(position.isActive, \"Position not active\");\r\n        require(position.shares >= _shares, \"Insufficient shares\");\r\n        \r\n        // Calculate withdrawal amount (simplified)\r\n        uint256 withdrawalAmount = position.amount * _shares / position.shares;\r\n        \r\n        position.shares -= _shares;\r\n        position.amount -= withdrawalAmount;\r\n        \r\n        if (position.shares == 0) {\r\n            position.isActive = false;\r\n        }\r\n        \r\n        userStablecoinBalances[msg.sender][position.stablecoin] += withdrawalAmount;\r\n        totalInvested -= withdrawalAmount;\r\n        \r\n        emit InvestmentWithdrawn(msg.sender, position.strategyId, withdrawalAmount);\r\n    }\r\n    \r\n    /**\r\n     * Deposit to emergency vault\r\n     */\r\n    function depositEmergencyFund(\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    ) external validStablecoin(_stablecoin) validAmount(_amount) {\r\n        require(\r\n            userStablecoinBalances[msg.sender][_stablecoin] >= _amount,\r\n            \"Insufficient balance\"\r\n        );\r\n        \r\n        if (!userEmergencyVaults[msg.sender].isActive) {\r\n            userEmergencyVaults[msg.sender] = EmergencyVault({\r\n                user: msg.sender,\r\n                stablecoin: _stablecoin,\r\n                balance: 0,\r\n                lastDepositTime: 0,\r\n                withdrawalCount: 0,\r\n                isActive: true\r\n            });\r\n        }\r\n        \r\n        userEmergencyVaults[msg.sender].balance += _amount;\r\n        userEmergencyVaults[msg.sender].lastDepositTime = block.timestamp;\r\n        userStablecoinBalances[msg.sender][_stablecoin] -= _amount;\r\n        \r\n        totalEmergencyFunds += _amount;\r\n        \r\n        emit EmergencyDeposit(msg.sender, _stablecoin, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from emergency vault (instant)\r\n     */\r\n    function withdrawEmergencyFund(\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    ) external validStablecoin(_stablecoin) validAmount(_amount) {\r\n        require(userEmergencyVaults[msg.sender].isActive, \"No emergency vault\");\r\n        require(\r\n            userEmergencyVaults[msg.sender].balance >= _amount,\r\n            \"Insufficient emergency balance\"\r\n        );\r\n        \r\n        userEmergencyVaults[msg.sender].balance -= _amount;\r\n        userEmergencyVaults[msg.sender].withdrawalCount++;\r\n        userStablecoinBalances[msg.sender][_stablecoin] += _amount;\r\n        \r\n        totalEmergencyFunds -= _amount;\r\n        \r\n        emit EmergencyWithdrawal(msg.sender, _stablecoin, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Create savings goal\r\n     */\r\n    function createSavingsGoal(\r\n        string memory _goalName,\r\n        uint256 _targetAmount,\r\n        uint256 _deadline\r\n    ) external validAmount(_targetAmount) {\r\n        require(_deadline > block.timestamp, \"Deadline must be in the future\");\r\n        \r\n        userGoals[msg.sender].push(SavingsGoal({\r\n            user: msg.sender,\r\n            goalName: _goalName,\r\n            targetAmount: _targetAmount,\r\n            currentAmount: 0,\r\n            deadline: _deadline,\r\n            isCompleted: false,\r\n            createdAt: block.timestamp\r\n        }));\r\n        \r\n        emit GoalCreated(msg.sender, _goalName, _targetAmount);\r\n    }\r\n    \r\n    /**\r\n     * Update goal progress\r\n     */\r\n    function updateGoalProgress(\r\n        uint256 _goalIndex,\r\n        uint256 _additionalAmount\r\n    ) external validAmount(_additionalAmount) {\r\n        require(_goalIndex < userGoals[msg.sender].length, \"Invalid goal index\");\r\n        \r\n        SavingsGoal storage goal = userGoals[msg.sender][_goalIndex];\r\n        require(!goal.isCompleted, \"Goal already completed\");\r\n        \r\n        goal.currentAmount += _additionalAmount;\r\n        \r\n        if (goal.currentAmount >= goal.targetAmount) {\r\n            goal.isCompleted = true;\r\n            emit GoalCompleted(msg.sender, goal.goalName);\r\n        }\r\n        \r\n        emit GoalUpdated(msg.sender, goal.goalName, goal.currentAmount);\r\n    }\r\n    \r\n    /**\r\n     * Get user's total portfolio value\r\n     */\r\n    function getPortfolioValue(address _user) external view returns (\r\n        uint256 totalSavings,\r\n        uint256 totalInvestments,\r\n        uint256 totalEmergency,\r\n        uint256 totalValue\r\n    ) {\r\n        totalSavings = userSavingsAccounts[_user].currentBalance;\r\n        totalEmergency = userEmergencyVaults[_user].balance;\r\n        \r\n        // Calculate total investments (simplified to avoid stack too deep)\r\n        InvestmentPosition[] memory investments = userInvestments[_user];\r\n        for (uint256 i = 0; i < investments.length; i++) {\r\n            if (investments[i].isActive) {\r\n                totalInvestments += investments[i].amount;\r\n            }\r\n        }\r\n        \r\n        totalValue = totalSavings + totalInvestments + totalEmergency;\r\n    }\r\n    \r\n    /**\r\n     * Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalUsers,\r\n        uint256 _totalDeposited,\r\n        uint256 _totalInvested,\r\n        uint256 _totalEmergencyFunds,\r\n        uint256 _platformFeeRate\r\n    ) {\r\n        return (totalUsers, totalDeposited, totalInvested, totalEmergencyFunds, platformFeeRate);\r\n    }\r\n    \r\n    /**\r\n     * Set platform fee rate (only owner)\r\n     */\r\n    function setPlatformFeeRate(uint256 _newRate) external onlyOwner {\r\n        require(_newRate <= 1000, \"Fee rate too high\"); // Max 10%\r\n        platformFeeRate = _newRate;\r\n    }\r\n    \r\n    /**\r\n     * Emergency function to pause platform (only owner)\r\n     */\r\n    function emergencyPause() external onlyOwner {\r\n        // In production, implement pausable functionality\r\n        // This would prevent new deposits/withdrawals\r\n    }\r\n}\r\n"
    },
    "contracts/SAFEToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * SAFEToken - Governance token for SafeNest platform\r\n * Enables premium features, governance, and fee sharing\r\n * @author SafeNest Team\r\n */\r\ncontract SAFEToken {\r\n    // Token Details\r\n    string public constant name = \"SafeNest Token\";\r\n    string public constant symbol = \"SAFE\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 * 10**18; // 1 billion tokens\r\n    \r\n    // Token Distribution\r\n    uint256 public constant COMMUNITY_ALLOCATION = 400_000_000 * 10**18; // 40%\r\n    uint256 public constant TEAM_ALLOCATION = 150_000_000 * 10**18; // 15%\r\n    uint256 public constant TREASURY_ALLOCATION = 200_000_000 * 10**18; // 20%\r\n    uint256 public constant LIQUIDITY_ALLOCATION = 100_000_000 * 10**18; // 10%\r\n    uint256 public constant PARTNERS_ALLOCATION = 100_000_000 * 10**18; // 10%\r\n    uint256 public constant EARLY_ADOPTERS = 50_000_000 * 10**18; // 5%\r\n    \r\n    // Staking Parameters\r\n    uint256 public constant STAKING_REWARDS_POOL = 300_000_000 * 10**18; // 30% for staking rewards\r\n    uint256 public constant REWARDS_DURATION = 4 * 365 days; // 4 years\r\n    uint256 public constant REWARDS_PER_SECOND = STAKING_REWARDS_POOL / REWARDS_DURATION;\r\n    \r\n    // Premium Feature Requirements\r\n    uint256 public constant PREMIUM_VAULT_STAKE = 10000 * 10**18; // 10k SAFE for premium vaults\r\n    uint256 public constant PREMIUM_WITHDRAWAL_STAKE = 5000 * 10**18; // 5k SAFE for instant withdrawal\r\n    uint256 public constant PREMIUM_TRANSFER_STAKE = 2000 * 10**18; // 2k SAFE for free transfers\r\n    uint256 public constant PREMIUM_INSURANCE_STAKE = 15000 * 10**18; // 15k SAFE for premium insurance\r\n    \r\n    // Governance Parameters\r\n    uint256 public constant MIN_STAKE_FOR_VOTING = 1000 * 10**18; // 1k SAFE minimum\r\n    uint256 public constant VOTING_DURATION = 3 days;\r\n    uint256 public constant EXECUTION_DELAY = 1 days;\r\n    uint256 public constant QUORUM_THRESHOLD = 5; // 5% of total staked\r\n    \r\n    // Referral System\r\n    uint256 public constant REFERRAL_BONUS_RATE = 100; // 1% of referred user's deposits\r\n    uint256 public constant REFERRAL_DURATION = 365 days; // 1 year\r\n    uint256 public constant MAX_REFERRAL_DEPTH = 3; // 3 levels deep\r\n    \r\n    // Community Rewards\r\n    uint256 public constant COMMUNITY_REWARDS_POOL = 100_000_000 * 10**18; // 100M for community rewards\r\n    uint256 public constant EDUCATION_REWARD = 100 * 10**18; // 100 SAFE per education module\r\n    uint256 public constant POOL_CREATION_REWARD = 500 * 10**18; // 500 SAFE for creating pools\r\n    uint256 public constant ACTIVE_USER_REWARD = 50 * 10**18; // 50 SAFE for active users\r\n    \r\n    // Protocol Fee Structure\r\n    uint256 public constant MIN_PROTOCOL_FEE = 10; // 0.1% minimum\r\n    uint256 public constant MAX_PROTOCOL_FEE = 30; // 0.3% maximum\r\n    uint256 public constant DEFAULT_PROTOCOL_FEE = 20; // 0.2% default\r\n    \r\n    // Fee Distribution\r\n    uint256 public constant STAKERS_FEE_SHARE = 60; // 60% to stakers\r\n    uint256 public constant TREASURY_FEE_SHARE = 25; // 25% to treasury\r\n    uint256 public constant BURN_FEE_SHARE = 15; // 15% burned (deflationary)\r\n    \r\n    // State Variables\r\n    address public immutable owner;\r\n    address public platformContract;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    mapping(address => bool) public isMinter;\r\n    \r\n    // Staking\r\n    struct Stake {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        uint256 lockPeriod;\r\n        bool isActive;\r\n    }\r\n    \r\n    mapping(address => Stake[]) public userStakes;\r\n    mapping(address => uint256) public totalStaked;\r\n    uint256 public totalStakedSupply = 0;\r\n    \r\n    // Governance\r\n    struct Proposal {\r\n        uint256 id;\r\n        address proposer;\r\n        string title;\r\n        string description;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 forVotes;\r\n        uint256 againstVotes;\r\n        bool executed;\r\n        mapping(address => bool) hasVoted;\r\n    }\r\n    \r\n    mapping(uint256 => Proposal) public proposals;\r\n    uint256 public nextProposalId = 1;\r\n    \r\n    // Referral System\r\n    mapping(address => address) public referrers;\r\n    mapping(address => uint256) public referralCount;\r\n    mapping(address => uint256) public totalReferralRewards;\r\n    \r\n    // Community Rewards\r\n    mapping(address => uint256) public educationScore;\r\n    mapping(address => uint256) public communityRewards;\r\n    mapping(address => bool) public hasCreatedPool;\r\n    mapping(address => uint256) public lastActiveTime;\r\n    \r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Staked(address indexed user, uint256 amount, uint256 lockPeriod);\r\n    event Unstaked(address indexed user, uint256 amount);\r\n    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string title);\r\n    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 votes);\r\n    event ProposalExecuted(uint256 indexed proposalId);\r\n    event ReferralRewardPaid(address indexed referrer, address indexed referee, uint256 amount);\r\n    event CommunityRewardEarned(address indexed user, string rewardType, uint256 amount);\r\n    event PremiumFeatureUnlocked(address indexed user, string feature, uint256 stakeAmount);\r\n    event ProtocolFeeUpdated(uint256 oldFee, uint256 newFee);\r\n    event FeeDistributed(uint256 stakersAmount, uint256 treasuryAmount, uint256 burnAmount);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyMinter() {\r\n        require(isMinter[msg.sender] || msg.sender == owner, \"Not a minter\");\r\n        _;\r\n    }\r\n    \r\n    modifier validAddress(address _addr) {\r\n        require(_addr != address(0), \"Invalid address\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n        balanceOf[owner] = TOTAL_SUPPLY;\r\n        emit Transfer(address(0), owner, TOTAL_SUPPLY);\r\n    }\r\n    \r\n    // ERC20 Functions\r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        require(_to != address(0), \"Transfer to zero address\");\r\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\r\n        \r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        \r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\r\n        require(_to != address(0), \"Transfer to zero address\");\r\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\r\n        require(allowance[_from][msg.sender] >= _value, \"Insufficient allowance\");\r\n        \r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        \r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    // Staking Functions\r\n    function stake(uint256 _amount, uint256 _lockPeriod) external {\r\n        require(balanceOf[msg.sender] >= _amount, \"Insufficient balance\");\r\n        require(_lockPeriod >= 30 days, \"Minimum lock period is 30 days\");\r\n        require(_lockPeriod <= 365 days, \"Maximum lock period is 1 year\");\r\n        \r\n        balanceOf[msg.sender] -= _amount;\r\n        totalStaked[msg.sender] += _amount;\r\n        totalStakedSupply += _amount;\r\n        \r\n        userStakes[msg.sender].push(Stake({\r\n            amount: _amount,\r\n            timestamp: block.timestamp,\r\n            lockPeriod: _lockPeriod,\r\n            isActive: true\r\n        }));\r\n        \r\n        emit Staked(msg.sender, _amount, _lockPeriod);\r\n    }\r\n    \r\n    function unstake(uint256 _stakeIndex) external {\r\n        require(_stakeIndex < userStakes[msg.sender].length, \"Invalid stake index\");\r\n        \r\n        Stake storage userStake = userStakes[msg.sender][_stakeIndex];\r\n        require(userStake.isActive, \"Stake not active\");\r\n        require(\r\n            block.timestamp >= userStake.timestamp + userStake.lockPeriod,\r\n            \"Stake still locked\"\r\n        );\r\n        \r\n        userStake.isActive = false;\r\n        totalStaked[msg.sender] -= userStake.amount;\r\n        totalStakedSupply -= userStake.amount;\r\n        balanceOf[msg.sender] += userStake.amount;\r\n        \r\n        emit Unstaked(msg.sender, userStake.amount);\r\n    }\r\n    \r\n    // Governance Functions\r\n    function createProposal(\r\n        string memory _title,\r\n        string memory _description\r\n    ) external {\r\n        require(totalStaked[msg.sender] >= MIN_STAKE_FOR_VOTING, \"Insufficient stake for proposal\");\r\n        \r\n        Proposal storage proposal = proposals[nextProposalId];\r\n        proposal.id = nextProposalId;\r\n        proposal.proposer = msg.sender;\r\n        proposal.title = _title;\r\n        proposal.description = _description;\r\n        proposal.startTime = block.timestamp;\r\n        proposal.endTime = block.timestamp + VOTING_DURATION;\r\n        proposal.forVotes = 0;\r\n        proposal.againstVotes = 0;\r\n        proposal.executed = false;\r\n        \r\n        emit ProposalCreated(nextProposalId, msg.sender, _title);\r\n        nextProposalId++;\r\n    }\r\n    \r\n    function vote(uint256 _proposalId, bool _support) external {\r\n        require(_proposalId < nextProposalId, \"Invalid proposal\");\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        require(block.timestamp >= proposal.startTime, \"Voting not started\");\r\n        require(block.timestamp <= proposal.endTime, \"Voting ended\");\r\n        require(!proposal.hasVoted[msg.sender], \"Already voted\");\r\n        require(totalStaked[msg.sender] > 0, \"No stake to vote\");\r\n        \r\n        proposal.hasVoted[msg.sender] = true;\r\n        uint256 votes = totalStaked[msg.sender];\r\n        \r\n        if (_support) {\r\n            proposal.forVotes += votes;\r\n        } else {\r\n            proposal.againstVotes += votes;\r\n        }\r\n        \r\n        emit VoteCast(_proposalId, msg.sender, _support, votes);\r\n    }\r\n    \r\n    function executeProposal(uint256 _proposalId) external {\r\n        require(_proposalId < nextProposalId, \"Invalid proposal\");\r\n        Proposal storage proposal = proposals[_proposalId];\r\n        require(block.timestamp > proposal.endTime, \"Voting not ended\");\r\n        require(!proposal.executed, \"Already executed\");\r\n        require(proposal.forVotes > proposal.againstVotes, \"Proposal rejected\");\r\n        require(proposal.forVotes >= (totalStakedSupply * QUORUM_THRESHOLD) / 100, \"Quorum not met\");\r\n        \r\n        proposal.executed = true;\r\n        emit ProposalExecuted(_proposalId);\r\n    }\r\n    \r\n    // Referral System\r\n    function setReferrer(address _referrer) external {\r\n        require(_referrer != address(0), \"Invalid referrer\");\r\n        require(_referrer != msg.sender, \"Cannot refer yourself\");\r\n        require(referrers[msg.sender] == address(0), \"Referrer already set\");\r\n        \r\n        referrers[msg.sender] = _referrer;\r\n        referralCount[_referrer]++;\r\n    }\r\n    \r\n    function payReferralReward(address _referee, uint256 _depositAmount) external onlyMinter {\r\n        address referrer = referrers[_referee];\r\n        if (referrer != address(0)) {\r\n            uint256 reward = (_depositAmount * REFERRAL_BONUS_RATE) / 10000;\r\n            totalReferralRewards[referrer] += reward;\r\n            balanceOf[referrer] += reward;\r\n            \r\n            emit ReferralRewardPaid(referrer, _referee, reward);\r\n        }\r\n    }\r\n    \r\n    // Community Rewards\r\n    function earnEducationReward(address _user) external onlyMinter {\r\n        educationScore[_user] += 100;\r\n        communityRewards[_user] += EDUCATION_REWARD;\r\n        balanceOf[_user] += EDUCATION_REWARD;\r\n        \r\n        emit CommunityRewardEarned(_user, \"Education\", EDUCATION_REWARD);\r\n    }\r\n    \r\n    function earnPoolCreationReward(address _user) external onlyMinter {\r\n        if (!hasCreatedPool[_user]) {\r\n            hasCreatedPool[_user] = true;\r\n            communityRewards[_user] += POOL_CREATION_REWARD;\r\n            balanceOf[_user] += POOL_CREATION_REWARD;\r\n            \r\n            emit CommunityRewardEarned(_user, \"Pool Creation\", POOL_CREATION_REWARD);\r\n        }\r\n    }\r\n    \r\n    function earnActiveUserReward(address _user) external onlyMinter {\r\n        if (block.timestamp - lastActiveTime[_user] >= 7 days) {\r\n            lastActiveTime[_user] = block.timestamp;\r\n            communityRewards[_user] += ACTIVE_USER_REWARD;\r\n            balanceOf[_user] += ACTIVE_USER_REWARD;\r\n            \r\n            emit CommunityRewardEarned(_user, \"Active User\", ACTIVE_USER_REWARD);\r\n        }\r\n    }\r\n    \r\n    // Premium Features\r\n    function checkPremiumVaultAccess(address _user) external view returns (bool) {\r\n        return totalStaked[_user] >= PREMIUM_VAULT_STAKE;\r\n    }\r\n    \r\n    function checkPremiumWithdrawalAccess(address _user) external view returns (bool) {\r\n        return totalStaked[_user] >= PREMIUM_WITHDRAWAL_STAKE;\r\n    }\r\n    \r\n    function checkPremiumTransferAccess(address _user) external view returns (bool) {\r\n        return totalStaked[_user] >= PREMIUM_TRANSFER_STAKE;\r\n    }\r\n    \r\n    function checkPremiumInsuranceAccess(address _user) external view returns (bool) {\r\n        return totalStaked[_user] >= PREMIUM_INSURANCE_STAKE;\r\n    }\r\n    \r\n    // Admin Functions\r\n    function setPlatformContract(address _platformContract) external onlyOwner {\r\n        platformContract = _platformContract;\r\n        isMinter[_platformContract] = true;\r\n    }\r\n    \r\n    function setMinter(address _minter, bool _status) external onlyOwner {\r\n        isMinter[_minter] = _status;\r\n    }\r\n    \r\n    function mint(address _to, uint256 _amount) external onlyMinter {\r\n        balanceOf[_to] += _amount;\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n    \r\n    // View Functions\r\n    function getStakingInfo(address _user) external view returns (\r\n        uint256 totalStakedAmount,\r\n        uint256 activeStakes,\r\n        uint256 totalRewards\r\n    ) {\r\n        return (\r\n            totalStaked[_user],\r\n            userStakes[_user].length,\r\n            communityRewards[_user]\r\n        );\r\n    }\r\n    \r\n    function getGovernanceInfo() external view returns (\r\n        uint256 totalStakedSupplyValue,\r\n        uint256 minStakeForVoting,\r\n        uint256 quorumThreshold\r\n    ) {\r\n        return (\r\n            totalStakedSupply,\r\n            MIN_STAKE_FOR_VOTING,\r\n            QUORUM_THRESHOLD\r\n        );\r\n    }\r\n    \r\n    function getReferralInfo(address _user) external view returns (\r\n        address referrer,\r\n        uint256 userReferralCount,\r\n        uint256 totalRewards\r\n    ) {\r\n        return (\r\n            referrers[_user],\r\n            referralCount[_user],\r\n            totalReferralRewards[_user]\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/SimpleMicroSavings.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n/**\r\n * SimpleMicroSavings - Simplified mobile-first DeFi savings platform\r\n * @author SafeNest Team\r\n */\r\ncontract SimpleMicroSavings {\r\n    // State Variables\r\n    address public immutable owner;\r\n    string public platformName = \"SimpleMicroSavings - Mobile DeFi Platform\";\r\n    \r\n    // User savings accounts\r\n    struct SavingsAccount {\r\n        address user;\r\n        uint256 totalDeposited;\r\n        uint256 totalWithdrawn;\r\n        uint256 currentBalance;\r\n        uint256 lastDepositTime;\r\n        bool isActive;\r\n    }\r\n    \r\n    // Investment strategies\r\n    struct InvestmentStrategy {\r\n        string name;\r\n        uint256 apy; // Annual percentage yield in basis points\r\n        bool isActive;\r\n        uint256 minDeposit;\r\n        uint256 maxDeposit;\r\n    }\r\n    \r\n    // User investment positions\r\n    struct InvestmentPosition {\r\n        address user;\r\n        uint256 strategyId;\r\n        uint256 amount;\r\n        uint256 entryTime;\r\n        bool isActive;\r\n    }\r\n    \r\n    // Emergency fund vault\r\n    struct EmergencyVault {\r\n        address user;\r\n        uint256 balance;\r\n        uint256 lastDepositTime;\r\n        bool isActive;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => SavingsAccount) public userSavingsAccounts;\r\n    mapping(uint256 => InvestmentStrategy) public investmentStrategies;\r\n    mapping(address => InvestmentPosition[]) public userInvestments;\r\n    mapping(address => EmergencyVault) public userEmergencyVaults;\r\n    \r\n    // Platform statistics\r\n    uint256 public totalUsers = 0;\r\n    uint256 public totalDeposited = 0;\r\n    uint256 public totalInvested = 0;\r\n    uint256 public totalEmergencyFunds = 0;\r\n    uint256 public platformFeeRate = 30; // 0.3% in basis points\r\n    uint256 public nextStrategyId = 1;\r\n    \r\n    // Events\r\n    event DepositMade(address indexed user, uint256 amount);\r\n    event WithdrawalMade(address indexed user, uint256 amount);\r\n    event InvestmentMade(address indexed user, uint256 strategyId, uint256 amount);\r\n    event EmergencyDeposit(address indexed user, uint256 amount);\r\n    event EmergencyWithdrawal(address indexed user, uint256 amount);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validAmount(uint256 _amount) {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * Add investment strategy\r\n     */\r\n    function addInvestmentStrategy(\r\n        string memory _name,\r\n        uint256 _apy,\r\n        uint256 _minDeposit,\r\n        uint256 _maxDeposit\r\n    ) external onlyOwner {\r\n        investmentStrategies[nextStrategyId] = InvestmentStrategy({\r\n            name: _name,\r\n            apy: _apy,\r\n            isActive: true,\r\n            minDeposit: _minDeposit,\r\n            maxDeposit: _maxDeposit\r\n        });\r\n        nextStrategyId++;\r\n    }\r\n    \r\n    /**\r\n     * Make micro-savings deposit\r\n     */\r\n    function depositSavings(uint256 _amount) external validAmount(_amount) payable {\r\n        require(msg.value >= _amount, \"Insufficient ETH sent\");\r\n        \r\n        // Update user savings account\r\n        if (!userSavingsAccounts[msg.sender].isActive) {\r\n            userSavingsAccounts[msg.sender] = SavingsAccount({\r\n                user: msg.sender,\r\n                totalDeposited: 0,\r\n                totalWithdrawn: 0,\r\n                currentBalance: 0,\r\n                lastDepositTime: 0,\r\n                isActive: true\r\n            });\r\n            totalUsers++;\r\n        }\r\n        \r\n        userSavingsAccounts[msg.sender].totalDeposited += _amount;\r\n        userSavingsAccounts[msg.sender].currentBalance += _amount;\r\n        userSavingsAccounts[msg.sender].lastDepositTime = block.timestamp;\r\n        \r\n        totalDeposited += _amount;\r\n        \r\n        emit DepositMade(msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from savings\r\n     */\r\n    function withdrawSavings(uint256 _amount) external validAmount(_amount) {\r\n        require(\r\n            userSavingsAccounts[msg.sender].currentBalance >= _amount,\r\n            \"Insufficient balance\"\r\n        );\r\n        \r\n        userSavingsAccounts[msg.sender].totalWithdrawn += _amount;\r\n        userSavingsAccounts[msg.sender].currentBalance -= _amount;\r\n        \r\n        totalDeposited -= _amount;\r\n        \r\n        // Transfer ETH to user\r\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit WithdrawalMade(msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Invest in DeFi strategy\r\n     */\r\n    function investInStrategy(\r\n        uint256 _strategyId,\r\n        uint256 _amount\r\n    ) external validAmount(_amount) payable {\r\n        InvestmentStrategy storage strategy = investmentStrategies[_strategyId];\r\n        require(strategy.isActive, \"Strategy not active\");\r\n        require(_amount >= strategy.minDeposit, \"Amount below minimum\");\r\n        require(_amount <= strategy.maxDeposit, \"Amount above maximum\");\r\n        require(msg.value >= _amount, \"Insufficient ETH sent\");\r\n        \r\n        userInvestments[msg.sender].push(InvestmentPosition({\r\n            user: msg.sender,\r\n            strategyId: _strategyId,\r\n            amount: _amount,\r\n            entryTime: block.timestamp,\r\n            isActive: true\r\n        }));\r\n        \r\n        totalInvested += _amount;\r\n        \r\n        emit InvestmentMade(msg.sender, _strategyId, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Deposit to emergency vault\r\n     */\r\n    function depositEmergencyFund(uint256 _amount) external validAmount(_amount) payable {\r\n        require(msg.value >= _amount, \"Insufficient ETH sent\");\r\n        \r\n        if (!userEmergencyVaults[msg.sender].isActive) {\r\n            userEmergencyVaults[msg.sender] = EmergencyVault({\r\n                user: msg.sender,\r\n                balance: 0,\r\n                lastDepositTime: 0,\r\n                isActive: true\r\n            });\r\n        }\r\n        \r\n        userEmergencyVaults[msg.sender].balance += _amount;\r\n        userEmergencyVaults[msg.sender].lastDepositTime = block.timestamp;\r\n        \r\n        totalEmergencyFunds += _amount;\r\n        \r\n        emit EmergencyDeposit(msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from emergency vault (instant)\r\n     */\r\n    function withdrawEmergencyFund(uint256 _amount) external validAmount(_amount) {\r\n        require(userEmergencyVaults[msg.sender].isActive, \"No emergency vault\");\r\n        require(\r\n            userEmergencyVaults[msg.sender].balance >= _amount,\r\n            \"Insufficient emergency balance\"\r\n        );\r\n        \r\n        userEmergencyVaults[msg.sender].balance -= _amount;\r\n        \r\n        totalEmergencyFunds -= _amount;\r\n        \r\n        // Transfer ETH to user\r\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit EmergencyWithdrawal(msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n     * Get user's total portfolio value\r\n     */\r\n    function getPortfolioValue(address _user) external view returns (\r\n        uint256 totalSavings,\r\n        uint256 totalInvestments,\r\n        uint256 totalEmergency,\r\n        uint256 totalValue\r\n    ) {\r\n        totalSavings = userSavingsAccounts[_user].currentBalance;\r\n        totalEmergency = userEmergencyVaults[_user].balance;\r\n        \r\n        // Calculate total investments\r\n        InvestmentPosition[] memory investments = userInvestments[_user];\r\n        for (uint256 i = 0; i < investments.length; i++) {\r\n            if (investments[i].isActive) {\r\n                totalInvestments += investments[i].amount;\r\n            }\r\n        }\r\n        \r\n        totalValue = totalSavings + totalInvestments + totalEmergency;\r\n    }\r\n    \r\n    /**\r\n     * Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalUsers,\r\n        uint256 _totalDeposited,\r\n        uint256 _totalInvested,\r\n        uint256 _totalEmergencyFunds,\r\n        uint256 _platformFeeRate\r\n    ) {\r\n        return (totalUsers, totalDeposited, totalInvested, totalEmergencyFunds, platformFeeRate);\r\n    }\r\n    \r\n    /**\r\n     * Set platform fee rate (only owner)\r\n     */\r\n    function setPlatformFeeRate(uint256 _newRate) external onlyOwner {\r\n        require(_newRate <= 1000, \"Fee rate too high\"); // Max 10%\r\n        platformFeeRate = _newRate;\r\n    }\r\n    \r\n    /**\r\n     * Withdraw platform fees (only owner)\r\n     */\r\n    function withdrawFees() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        \r\n        (bool success, ) = owner.call{value: balance}(\"\");\r\n        require(success, \"Failed to withdraw fees\");\r\n    }\r\n    \r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/VaultSystem.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * VaultSystem - Comprehensive vault system for SafeNest platform\r\n * Implements micro-savings, pension nest, and emergency vaults\r\n * @author SafeNest Team\r\n */\r\ncontract VaultSystem {\r\n    // State Variables\r\n    address public immutable owner;\r\n    address public safeToken;\r\n    string public platformName = \"SafeNest Vault System\";\r\n    \r\n    // Vault Types\r\n    enum VaultType {\r\n        MICRO_SAVINGS,    // Daily/weekly micro-savings\r\n        PENSION_NEST,     // Long-term retirement savings\r\n        EMERGENCY_VAULT   // Liquid emergency fund\r\n    }\r\n    \r\n    // User Vault Structure\r\n    struct UserVault {\r\n        address user;\r\n        VaultType vaultType;\r\n        uint256 totalDeposited;\r\n        uint256 currentBalance;\r\n        uint256 totalWithdrawn;\r\n        uint256 lastDepositTime;\r\n        uint256 lastWithdrawalTime;\r\n        uint256 yieldEarned;\r\n        bool isActive;\r\n        uint256 autoDepositAmount;\r\n        uint256 autoDepositFrequency; // in days\r\n        uint256 nextAutoDeposit;\r\n    }\r\n    \r\n    // Yield Strategy Structure\r\n    struct YieldStrategy {\r\n        uint256 id;\r\n        string name;\r\n        address strategyContract;\r\n        uint256 apy;\r\n        uint256 riskLevel; // 1=Low, 2=Medium, 3=High\r\n        bool isActive;\r\n        uint256 minDeposit;\r\n        uint256 maxDeposit;\r\n        uint256 totalDeposited;\r\n    }\r\n    \r\n    // Insurance Policy Structure\r\n    struct InsurancePolicy {\r\n        address user;\r\n        uint256 coverageAmount;\r\n        uint256 premiumRate;\r\n        uint256 coverageStartTime;\r\n        uint256 coverageEndTime;\r\n        bool isActive;\r\n        uint256 claimsCount;\r\n        uint256 totalClaimsPaid;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(address => mapping(VaultType => UserVault)) public userVaults;\r\n    mapping(uint256 => YieldStrategy) public yieldStrategies;\r\n    mapping(address => InsurancePolicy) public insurancePolicies;\r\n    mapping(address => bool) public hasPremiumAccess;\r\n    \r\n    // Platform Statistics\r\n    uint256 public totalUsers = 0;\r\n    uint256 public totalDeposited = 0;\r\n    uint256 public totalWithdrawn = 0;\r\n    uint256 public totalYieldEarned = 0;\r\n    uint256 public totalInsurancePolicies = 0;\r\n    \r\n    // Platform Parameters\r\n    uint256 public protocolFeeRate = 20; // 0.2% in basis points\r\n    uint256 public emergencyWithdrawalFee = 50; // 0.5%\r\n    uint256 public pensionYieldBoost = 200; // 2%\r\n    uint256 public microSavingsYieldBoost = 100; // 1%\r\n    uint256 public emergencyIncentiveRate = 25; // 0.25%\r\n    \r\n    // Counters\r\n    uint256 public nextYieldStrategyId = 1;\r\n    \r\n    // Events\r\n    event VaultCreated(address indexed user, VaultType vaultType, uint256 timestamp);\r\n    event DepositMade(address indexed user, VaultType vaultType, uint256 amount, uint256 timestamp);\r\n    event WithdrawalMade(address indexed user, VaultType vaultType, uint256 amount, uint256 fee, uint256 timestamp);\r\n    event AutoDepositEnabled(address indexed user, VaultType vaultType, uint256 amount, uint256 frequency);\r\n    event AutoDepositExecuted(address indexed user, VaultType vaultType, uint256 amount, uint256 timestamp);\r\n    event YieldStrategyAdded(uint256 indexed strategyId, string name, uint256 apy, uint256 riskLevel);\r\n    event YieldEarned(address indexed user, VaultType vaultType, uint256 amount, uint256 timestamp);\r\n    event InsurancePolicyPurchased(address indexed user, uint256 coverageAmount, uint256 premiumRate);\r\n    event InsuranceClaimProcessed(address indexed user, uint256 claimAmount, uint256 timestamp);\r\n    event PremiumAccessGranted(address indexed user, string feature, uint256 timestamp);\r\n    event ProtocolFeeUpdated(uint256 oldFee, uint256 newFee);\r\n    event EmergencyWithdrawal(address indexed user, uint256 amount, uint256 fee, uint256 timestamp);\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier validVaultType(VaultType _vaultType) {\r\n        require(_vaultType >= VaultType.MICRO_SAVINGS && _vaultType <= VaultType.EMERGENCY_VAULT, \"Invalid vault type\");\r\n        _;\r\n    }\r\n    \r\n    modifier validAmount(uint256 _amount) {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        _;\r\n    }\r\n    \r\n    modifier hasVault(address _user, VaultType _vaultType) {\r\n        require(userVaults[_user][_vaultType].isActive, \"Vault not active\");\r\n        _;\r\n    }\r\n    \r\n    // Constructor\r\n    constructor(address _safeToken) {\r\n        owner = msg.sender;\r\n        safeToken = _safeToken;\r\n    }\r\n    \r\n    /**\r\n     * Create a new vault\r\n     */\r\n    function createVault(VaultType _vaultType) external validVaultType(_vaultType) {\r\n        require(!userVaults[msg.sender][_vaultType].isActive, \"Vault already exists\");\r\n        \r\n        userVaults[msg.sender][_vaultType] = UserVault({\r\n            user: msg.sender,\r\n            vaultType: _vaultType,\r\n            totalDeposited: 0,\r\n            currentBalance: 0,\r\n            totalWithdrawn: 0,\r\n            lastDepositTime: 0,\r\n            lastWithdrawalTime: 0,\r\n            yieldEarned: 0,\r\n            isActive: true,\r\n            autoDepositAmount: 0,\r\n            autoDepositFrequency: 0,\r\n            nextAutoDeposit: 0\r\n        });\r\n        \r\n        totalUsers++;\r\n        \r\n        emit VaultCreated(msg.sender, _vaultType, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Make a deposit to vault\r\n     */\r\n    function depositToVault(VaultType _vaultType, uint256 _amount) external validVaultType(_vaultType) validAmount(_amount) payable {\r\n        require(userVaults[msg.sender][_vaultType].isActive, \"Vault not active\");\r\n        require(msg.value >= _amount, \"Insufficient ETH sent\");\r\n        \r\n        UserVault storage vault = userVaults[msg.sender][_vaultType];\r\n        \r\n        // Apply vault-specific logic\r\n        if (_vaultType == VaultType.MICRO_SAVINGS) {\r\n            require(_amount >= 0.001 ether, \"Minimum deposit for micro-savings is 0.001 ETH\");\r\n        } else if (_vaultType == VaultType.PENSION_NEST) {\r\n            require(_amount >= 0.01 ether, \"Minimum deposit for pension nest is 0.01 ETH\");\r\n        } else if (_vaultType == VaultType.EMERGENCY_VAULT) {\r\n            require(_amount >= 0.005 ether, \"Minimum deposit for emergency vault is 0.005 ETH\");\r\n        }\r\n        \r\n        vault.totalDeposited += _amount;\r\n        vault.currentBalance += _amount;\r\n        vault.lastDepositTime = block.timestamp;\r\n        \r\n        totalDeposited += _amount;\r\n        \r\n        emit DepositMade(msg.sender, _vaultType, _amount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw from vault\r\n     */\r\n    function withdrawFromVault(VaultType _vaultType, uint256 _amount) external validVaultType(_vaultType) validAmount(_amount) hasVault(msg.sender, _vaultType) {\r\n        UserVault storage vault = userVaults[msg.sender][_vaultType];\r\n        require(vault.currentBalance >= _amount, \"Insufficient balance\");\r\n        \r\n        uint256 fee = 0;\r\n        \r\n        // Apply vault-specific withdrawal logic\r\n        if (_vaultType == VaultType.EMERGENCY_VAULT) {\r\n            // Emergency vault has instant withdrawal with small fee\r\n            fee = (_amount * emergencyWithdrawalFee) / 10000;\r\n        } else if (_vaultType == VaultType.PENSION_NEST) {\r\n            // Pension nest has time-locked withdrawals\r\n            require(block.timestamp >= vault.lastDepositTime + 365 days, \"Pension withdrawals locked for 1 year\");\r\n        }\r\n        \r\n        uint256 netAmount = _amount - fee;\r\n        \r\n        vault.currentBalance -= _amount;\r\n        vault.totalWithdrawn += _amount;\r\n        vault.lastWithdrawalTime = block.timestamp;\r\n        \r\n        totalWithdrawn += _amount;\r\n        \r\n        // Transfer funds to user\r\n        (bool success, ) = msg.sender.call{value: netAmount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit WithdrawalMade(msg.sender, _vaultType, _amount, fee, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Enable auto-deposit for vault\r\n     */\r\n    function enableAutoDeposit(\r\n        VaultType _vaultType,\r\n        uint256 _amount,\r\n        uint256 _frequency\r\n    ) external validVaultType(_vaultType) hasVault(msg.sender, _vaultType) {\r\n        require(_amount > 0, \"Auto-deposit amount must be positive\");\r\n        require(_frequency >= 1, \"Frequency must be at least 1 day\");\r\n        require(_frequency <= 365, \"Frequency cannot exceed 1 year\");\r\n        \r\n        UserVault storage vault = userVaults[msg.sender][_vaultType];\r\n        vault.autoDepositAmount = _amount;\r\n        vault.autoDepositFrequency = _frequency;\r\n        vault.nextAutoDeposit = block.timestamp + _frequency * 1 days;\r\n        \r\n        emit AutoDepositEnabled(msg.sender, _vaultType, _amount, _frequency);\r\n    }\r\n    \r\n    /**\r\n     * Execute auto-deposit (called by user or automated system)\r\n     */\r\n    function executeAutoDeposit(VaultType _vaultType) external payable validVaultType(_vaultType) hasVault(msg.sender, _vaultType) {\r\n        UserVault storage vault = userVaults[msg.sender][_vaultType];\r\n        require(vault.autoDepositAmount > 0, \"Auto-deposit not enabled\");\r\n        require(block.timestamp >= vault.nextAutoDeposit, \"Auto-deposit not due yet\");\r\n        require(msg.value >= vault.autoDepositAmount, \"Insufficient ETH for auto-deposit\");\r\n        \r\n        vault.totalDeposited += vault.autoDepositAmount;\r\n        vault.currentBalance += vault.autoDepositAmount;\r\n        vault.lastDepositTime = block.timestamp;\r\n        vault.nextAutoDeposit = block.timestamp + vault.autoDepositFrequency * 1 days;\r\n        \r\n        totalDeposited += vault.autoDepositAmount;\r\n        \r\n        emit AutoDepositExecuted(msg.sender, _vaultType, vault.autoDepositAmount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Add yield strategy\r\n     */\r\n    function addYieldStrategy(\r\n        string memory _name,\r\n        address _strategyContract,\r\n        uint256 _apy,\r\n        uint256 _riskLevel,\r\n        uint256 _minDeposit,\r\n        uint256 _maxDeposit\r\n    ) external onlyOwner {\r\n        require(_apy > 0, \"APY must be positive\");\r\n        require(_riskLevel >= 1 && _riskLevel <= 3, \"Risk level must be 1-3\");\r\n        require(_minDeposit > 0, \"Minimum deposit must be positive\");\r\n        \r\n        yieldStrategies[nextYieldStrategyId] = YieldStrategy({\r\n            id: nextYieldStrategyId,\r\n            name: _name,\r\n            strategyContract: _strategyContract,\r\n            apy: _apy,\r\n            riskLevel: _riskLevel,\r\n            isActive: true,\r\n            minDeposit: _minDeposit,\r\n            maxDeposit: _maxDeposit,\r\n            totalDeposited: 0\r\n        });\r\n        \r\n        emit YieldStrategyAdded(nextYieldStrategyId, _name, _apy, _riskLevel);\r\n        nextYieldStrategyId++;\r\n    }\r\n    \r\n    /**\r\n     * Calculate and distribute yield\r\n     */\r\n    function calculateYield(address _user, VaultType _vaultType) external validVaultType(_vaultType) hasVault(_user, _vaultType) {\r\n        UserVault storage vault = userVaults[_user][_vaultType];\r\n        require(vault.currentBalance > 0, \"No balance to calculate yield\");\r\n        \r\n        // Calculate yield based on vault type and strategy\r\n        uint256 baseYield = 0;\r\n        uint256 yieldBoost = 0;\r\n        \r\n        if (_vaultType == VaultType.MICRO_SAVINGS) {\r\n            baseYield = (vault.currentBalance * 300) / 10000; // 3% base APY\r\n            yieldBoost = (vault.currentBalance * microSavingsYieldBoost) / 10000; // 1% boost\r\n        } else if (_vaultType == VaultType.PENSION_NEST) {\r\n            baseYield = (vault.currentBalance * 500) / 10000; // 5% base APY\r\n            yieldBoost = (vault.currentBalance * pensionYieldBoost) / 10000; // 2% boost\r\n        } else if (_vaultType == VaultType.EMERGENCY_VAULT) {\r\n            baseYield = (vault.currentBalance * 200) / 10000; // 2% base APY\r\n            yieldBoost = (vault.currentBalance * emergencyIncentiveRate) / 10000; // 0.25% boost\r\n        }\r\n        \r\n        uint256 totalYield = baseYield + yieldBoost;\r\n        uint256 protocolFee = (totalYield * protocolFeeRate) / 10000;\r\n        uint256 netYield = totalYield - protocolFee;\r\n        \r\n        vault.currentBalance += netYield;\r\n        vault.yieldEarned += netYield;\r\n        totalYieldEarned += netYield;\r\n        \r\n        emit YieldEarned(_user, _vaultType, netYield, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Purchase insurance policy\r\n     */\r\n    function purchaseInsurance(uint256 _coverageAmount) external validAmount(_coverageAmount) {\r\n        require(!insurancePolicies[msg.sender].isActive, \"Insurance already active\");\r\n        \r\n        insurancePolicies[msg.sender] = InsurancePolicy({\r\n            user: msg.sender,\r\n            coverageAmount: _coverageAmount,\r\n            premiumRate: 10, // 0.1% premium\r\n            coverageStartTime: block.timestamp,\r\n            coverageEndTime: block.timestamp + 365 days,\r\n            isActive: true,\r\n            claimsCount: 0,\r\n            totalClaimsPaid: 0\r\n        });\r\n        \r\n        totalInsurancePolicies++;\r\n        \r\n        emit InsurancePolicyPurchased(msg.sender, _coverageAmount, 10);\r\n    }\r\n    \r\n    /**\r\n     * Process insurance claim\r\n     */\r\n    function processInsuranceClaim(uint256 _claimAmount) external {\r\n        InsurancePolicy storage policy = insurancePolicies[msg.sender];\r\n        require(policy.isActive, \"No active insurance policy\");\r\n        require(block.timestamp <= policy.coverageEndTime, \"Insurance expired\");\r\n        require(_claimAmount <= policy.coverageAmount, \"Claim exceeds coverage\");\r\n        \r\n        policy.claimsCount++;\r\n        policy.totalClaimsPaid += _claimAmount;\r\n        \r\n        // Transfer claim amount to user\r\n        (bool success, ) = msg.sender.call{value: _claimAmount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        \r\n        emit InsuranceClaimProcessed(msg.sender, _claimAmount, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Check premium access\r\n     */\r\n    function checkPremiumAccess(address _user) external view returns (bool) {\r\n        return hasPremiumAccess[_user];\r\n    }\r\n    \r\n    /**\r\n     * Grant premium access (called by SAFE token contract)\r\n     */\r\n    function grantPremiumAccess(address _user) external {\r\n        require(msg.sender == safeToken, \"Only SAFE token can grant premium access\");\r\n        hasPremiumAccess[_user] = true;\r\n        \r\n        emit PremiumAccessGranted(_user, \"Premium Vault Access\", block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * Get vault details\r\n     */\r\n    function getVaultDetails(address _user, VaultType _vaultType) external view validVaultType(_vaultType) returns (\r\n        uint256 vaultTotalDeposited,\r\n        uint256 currentBalance,\r\n        uint256 vaultTotalWithdrawn,\r\n        uint256 yieldEarned,\r\n        uint256 lastDepositTime,\r\n        uint256 lastWithdrawalTime,\r\n        bool isActive,\r\n        uint256 autoDepositAmount,\r\n        uint256 autoDepositFrequency\r\n    ) {\r\n        UserVault memory vault = userVaults[_user][_vaultType];\r\n        return (\r\n            vault.totalDeposited,\r\n            vault.currentBalance,\r\n            vault.totalWithdrawn,\r\n            vault.yieldEarned,\r\n            vault.lastDepositTime,\r\n            vault.lastWithdrawalTime,\r\n            vault.isActive,\r\n            vault.autoDepositAmount,\r\n            vault.autoDepositFrequency\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Get platform statistics\r\n     */\r\n    function getPlatformStats() external view returns (\r\n        uint256 _totalUsers,\r\n        uint256 _totalDeposited,\r\n        uint256 _totalWithdrawn,\r\n        uint256 _totalYieldEarned,\r\n        uint256 _totalInsurancePolicies,\r\n        uint256 _protocolFeeRate\r\n    ) {\r\n        return (\r\n            totalUsers,\r\n            totalDeposited,\r\n            totalWithdrawn,\r\n            totalYieldEarned,\r\n            totalInsurancePolicies,\r\n            protocolFeeRate\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Admin functions\r\n     */\r\n    function setProtocolFeeRate(uint256 _newRate) external onlyOwner {\r\n        require(_newRate >= 10 && _newRate <= 30, \"Fee rate must be between 0.1% and 0.3%\");\r\n        uint256 oldRate = protocolFeeRate;\r\n        protocolFeeRate = _newRate;\r\n        emit ProtocolFeeUpdated(oldRate, _newRate);\r\n    }\r\n    \r\n    function setEmergencyWithdrawalFee(uint256 _newFee) external onlyOwner {\r\n        require(_newFee <= 100, \"Fee cannot exceed 1%\");\r\n        emergencyWithdrawalFee = _newFee;\r\n    }\r\n    \r\n    function setPensionYieldBoost(uint256 _newBoost) external onlyOwner {\r\n        require(_newBoost <= 500, \"Boost cannot exceed 5%\");\r\n        pensionYieldBoost = _newBoost;\r\n    }\r\n    \r\n    function setMicroSavingsYieldBoost(uint256 _newBoost) external onlyOwner {\r\n        require(_newBoost <= 200, \"Boost cannot exceed 2%\");\r\n        microSavingsYieldBoost = _newBoost;\r\n    }\r\n    \r\n    function withdrawPlatformFees() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        \r\n        (bool success, ) = owner.call{value: balance}(\"\");\r\n        require(success, \"Failed to withdraw fees\");\r\n    }\r\n    \r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/YourContract.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// Useful for debugging. Remove when deploying to a live network.\r\nimport \"hardhat/console.sol\";\r\n\r\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * SafeNest - A decentralized help and support system\r\n * Allows users to request help, provide assistance, and manage community support\r\n * @author SafeNest Team\r\n */\r\ncontract SafeNest {\r\n    // State Variables\r\n    address public immutable owner;\r\n    string public platformName = \"SafeNest - Decentralized Help Platform\";\r\n    uint256 public totalHelpRequests = 0;\r\n    uint256 public totalHelpProvided = 0;\r\n    uint256 public platformFee = 0.01 ether; // 0.01 ETH fee for premium help requests\r\n    \r\n    // Help Request Structure\r\n    struct HelpRequest {\r\n        uint256 id;\r\n        address requester;\r\n        string title;\r\n        string description;\r\n        string category;\r\n        uint256 reward;\r\n        bool isResolved;\r\n        bool isPremium;\r\n        uint256 createdAt;\r\n        address helper;\r\n        string solution;\r\n        uint256 resolvedAt;\r\n    }\r\n    \r\n    // User Profile Structure\r\n    struct UserProfile {\r\n        string name;\r\n        string bio;\r\n        uint256 helpRequestsCount;\r\n        uint256 helpProvidedCount;\r\n        uint256 reputation;\r\n        bool isVerified;\r\n        string[] skills;\r\n    }\r\n    \r\n    // Mappings\r\n    mapping(uint256 => HelpRequest) public helpRequests;\r\n    mapping(address => UserProfile) public userProfiles;\r\n    mapping(address => uint256[]) public userHelpRequests;\r\n    mapping(address => uint256[]) public userHelpProvided;\r\n    mapping(string => uint256[]) public categoryRequests;\r\n    mapping(address => bool) public isHelper;\r\n    \r\n    // Events\r\n    event HelpRequestCreated(\r\n        uint256 indexed requestId,\r\n        address indexed requester,\r\n        string title,\r\n        string category,\r\n        uint256 reward,\r\n        bool isPremium\r\n    );\r\n    \r\n    event HelpRequestResolved(\r\n        uint256 indexed requestId,\r\n        address indexed helper,\r\n        string solution\r\n    );\r\n    \r\n    event UserProfileUpdated(address indexed user, string name, string bio);\r\n    event HelperRegistered(address indexed helper, string[] skills);\r\n    event RewardClaimed(uint256 indexed requestId, address indexed helper, uint256 amount);\r\n    \r\n    // Constructor\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyHelper() {\r\n        require(isHelper[msg.sender], \"Not a registered helper\");\r\n        _;\r\n    }\r\n    \r\n    modifier validRequestId(uint256 _requestId) {\r\n        require(_requestId < totalHelpRequests, \"Invalid request ID\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyRequesterOrHelper(uint256 _requestId) {\r\n        HelpRequest storage request = helpRequests[_requestId];\r\n        require(\r\n            msg.sender == request.requester || msg.sender == request.helper,\r\n            \"Not authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Create a new help request\r\n     */\r\n    function createHelpRequest(\r\n        string memory _title,\r\n        string memory _description,\r\n        string memory _category,\r\n        bool _isPremium\r\n    ) public payable returns (uint256) {\r\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\r\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\r\n        require(bytes(_category).length > 0, \"Category cannot be empty\");\r\n        \r\n        if (_isPremium) {\r\n            require(msg.value >= platformFee, \"Insufficient fee for premium request\");\r\n        }\r\n        \r\n        uint256 requestId = totalHelpRequests;\r\n        uint256 reward = _isPremium ? msg.value - platformFee : 0;\r\n        \r\n        helpRequests[requestId] = HelpRequest({\r\n            id: requestId,\r\n            requester: msg.sender,\r\n            title: _title,\r\n            description: _description,\r\n            category: _category,\r\n            reward: reward,\r\n            isResolved: false,\r\n            isPremium: _isPremium,\r\n            createdAt: block.timestamp,\r\n            helper: address(0),\r\n            solution: \"\",\r\n            resolvedAt: 0\r\n        });\r\n        \r\n        userHelpRequests[msg.sender].push(requestId);\r\n        categoryRequests[_category].push(requestId);\r\n        totalHelpRequests++;\r\n        \r\n        emit HelpRequestCreated(requestId, msg.sender, _title, _category, reward, _isPremium);\r\n        \r\n        return requestId;\r\n    }\r\n    \r\n    /**\r\n     * Register as a helper\r\n     */\r\n    function registerAsHelper(string memory _name, string memory _bio, string[] memory _skills) public {\r\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\r\n        require(_skills.length > 0, \"Must provide at least one skill\");\r\n        \r\n        userProfiles[msg.sender] = UserProfile({\r\n            name: _name,\r\n            bio: _bio,\r\n            helpRequestsCount: 0,\r\n            helpProvidedCount: 0,\r\n            reputation: 0,\r\n            isVerified: false,\r\n            skills: _skills\r\n        });\r\n        \r\n        isHelper[msg.sender] = true;\r\n        \r\n        emit HelperRegistered(msg.sender, _skills);\r\n    }\r\n    \r\n    /**\r\n     * Provide help for a request\r\n     */\r\n    function provideHelp(uint256 _requestId, string memory _solution) \r\n        public \r\n        onlyHelper \r\n        validRequestId(_requestId) \r\n    {\r\n        HelpRequest storage request = helpRequests[_requestId];\r\n        require(!request.isResolved, \"Request already resolved\");\r\n        require(request.helper == address(0), \"Request already assigned\");\r\n        \r\n        request.helper = msg.sender;\r\n        request.solution = _solution;\r\n        request.isResolved = true;\r\n        request.resolvedAt = block.timestamp;\r\n        \r\n        // Update user stats\r\n        userProfiles[msg.sender].helpProvidedCount++;\r\n        userProfiles[request.requester].helpRequestsCount++;\r\n        userProfiles[msg.sender].reputation += 10; // Reputation points for helping\r\n        \r\n        totalHelpProvided++;\r\n        \r\n        // Transfer reward to helper\r\n        if (request.reward > 0) {\r\n            (bool success, ) = msg.sender.call{value: request.reward}(\"\");\r\n            require(success, \"Failed to transfer reward\");\r\n        }\r\n        \r\n        userHelpProvided[msg.sender].push(_requestId);\r\n        \r\n        emit HelpRequestResolved(_requestId, msg.sender, _solution);\r\n        emit RewardClaimed(_requestId, msg.sender, request.reward);\r\n    }\r\n    \r\n    /**\r\n     * Get help request details\r\n     */\r\n    function getHelpRequest(uint256 _requestId) \r\n        public \r\n        view \r\n        validRequestId(_requestId) \r\n        returns (HelpRequest memory) \r\n    {\r\n        return helpRequests[_requestId];\r\n    }\r\n    \r\n    /**\r\n     * Get user profile\r\n     */\r\n    function getUserProfile(address _user) public view returns (UserProfile memory) {\r\n        return userProfiles[_user];\r\n    }\r\n    \r\n    /**\r\n     * Get help requests by category\r\n     */\r\n    function getHelpRequestsByCategory(string memory _category) \r\n        public \r\n        view \r\n        returns (uint256[] memory) \r\n    {\r\n        return categoryRequests[_category];\r\n    }\r\n    \r\n    /**\r\n     * Get user's help requests\r\n     */\r\n    function getUserHelpRequests(address _user) public view returns (uint256[] memory) {\r\n        return userHelpRequests[_user];\r\n    }\r\n    \r\n    /**\r\n     * Get user's help provided\r\n     */\r\n    function getUserHelpProvided(address _user) public view returns (uint256[] memory) {\r\n        return userHelpProvided[_user];\r\n    }\r\n    \r\n    /**\r\n     * Update user profile\r\n     */\r\n    function updateProfile(string memory _name, string memory _bio) public {\r\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\r\n        \r\n        userProfiles[msg.sender].name = _name;\r\n        userProfiles[msg.sender].bio = _bio;\r\n        \r\n        emit UserProfileUpdated(msg.sender, _name, _bio);\r\n    }\r\n    \r\n    /**\r\n     * Verify a helper (only owner)\r\n     */\r\n    function verifyHelper(address _helper) public onlyOwner {\r\n        require(isHelper[_helper], \"User is not a helper\");\r\n        userProfiles[_helper].isVerified = true;\r\n    }\r\n    \r\n    /**\r\n     * Set platform fee (only owner)\r\n     */\r\n    function setPlatformFee(uint256 _newFee) public onlyOwner {\r\n        platformFee = _newFee;\r\n    }\r\n    \r\n    /**\r\n     * Withdraw platform fees (only owner)\r\n     */\r\n    function withdrawFees() public onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        \r\n        (bool success, ) = owner.call{value: balance}(\"\");\r\n        require(success, \"Failed to withdraw fees\");\r\n    }\r\n    \r\n    /**\r\n     * Get platform statistics\r\n     */\r\n    function getPlatformStats() public view returns (\r\n        uint256 _totalRequests,\r\n        uint256 _totalHelpProvided,\r\n        uint256 _totalHelpers,\r\n        uint256 _platformBalance\r\n    ) {\r\n        return (\r\n            totalHelpRequests,\r\n            totalHelpProvided,\r\n            // Note: This is a simplified count - in production, you'd want to track this properly\r\n            totalHelpRequests, // Placeholder for total helpers\r\n            address(this).balance\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Function that allows the contract to receive ETH\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}